# 问题和解决方案的可视化总结

## 🎨 问题演示图

### 当前错误的布局

```
┌─────────────────────────────────────────────────────────┐
│                      画布 (Canvas)                       │
│                                                         │
│  ❌ 当前显示顺序（错误）                                │
│                                                         │
│  Y轴                                                   │
│  ↑                                                     │
│  │                                                     │
│150│   ┌──────────────────────────────────┐             │
│   │   │ USDCHolding                      │             │
│   │   │ (input, y=150)                   │             │
│   │   └──────────────────────────────────┘             │
│   │                                                     │
│300│   ┌──────────────────────────────────┐             │
│   │   │ nonUSDCHolding                   │             │
│   │   │ (array with table, y=300)        │             │
│   │   │ ┌──────────────┐                 │             │
│   │   │ │ holding ...  │                 │             │
│   │   │ │ indexPrice   │                 │             │
│   │   │ └──────────────┘                 │             │
│   │   └──────────────────────────────────┘             │
│   │                                                     │
│  0│   ┌──────────────────────────────────┐             │
│   │   │ totalUnsettlementPnL             │             │
│   │   │ (input, y=0)                     │  ← 最后的项│
│   │   │ 竟然在最上面！❌                 │     却在最上│
│   │   └──────────────────────────────────┘             │
│   │                                                     │
│   └─────────────────────────────────────→ X轴          │
│                                                         │
│  定义顺序：                                            │
│  1️⃣  nonUSDCHolding                                   │
│  2️⃣  USDCHolding                                      │
│  3️⃣  totalUnsettlementPnL                             │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

### 修复后的正确布局

```
┌─────────────────────────────────────────────────────────┐
│                      画布 (Canvas)                       │
│                                                         │
│  ✅ 修复后显示顺序（正确）                              │
│                                                         │
│  Y轴                                                   │
│  ↑                                                     │
│100│   ┌──────────────────────────────────┐             │
│   │   │ nonUSDCHolding                   │             │
│   │   │ (array with table, y=100)        │             │
│   │   │ ┌──────────────┐                 │ ← 第一项✅  │
│   │   │ │ holding ...  │                 │    在最上面 │
│   │   │ │ indexPrice   │                 │             │
│   │   │ └──────────────┘                 │             │
│   │   └──────────────────────────────────┘             │
│   │                                                     │
│240│   ┌──────────────────────────────────┐             │
│   │   │ USDCHolding                      │             │
│   │   │ (input, y=240)                   │             │
│   │   └──────────────────────────────────┘             │
│   │                                                     │
│370│   ┌──────────────────────────────────┐             │
│   │   │ totalUnsettlementPnL             │             │
│   │   │ (input, y=370)                   │ ← 最后的项✅│
│   │   └──────────────────────────────────┘    在最下面 │
│   │                                                     │
│   └─────────────────────────────────────→ X轴          │
│                                                         │
│  定义顺序：                                            │
│  1️⃣  nonUSDCHolding                                   │
│  2️⃣  USDCHolding                                      │
│  3️⃣  totalUnsettlementPnL                             │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

---

## 🔄 问题发生过程

```
┌──────────────────────────────────────────────────────────┐
│ 第 1 步：创建节点（保持顺序）                            │
├──────────────────────────────────────────────────────────┤
│                                                          │
│  nodes = [                                              │
│    { id: "array-nonUSDCHolding", type: "array" },  ← 1 │
│    { id: "input-USDCHolding", type: "input" },    ← 2  │
│    { id: "input-totalUnsettlement", type: "input" } ← 3│
│  ]                                                      │
│                                                          │
└──────────────────────────────────────────────────────────┘
                           ↓
┌──────────────────────────────────────────────────────────┐
│ 第 2 步：创建连接（所有指向 formula）                    │
├──────────────────────────────────────────────────────────┤
│                                                          │
│  edges = [                                              │
│    { source: "array-nonUSDCHolding", target: "formula" }│
│    { source: "input-USDCHolding", target: "formula" }   │
│    { source: "input-totalUnsettlement", target: "formula"} │
│  ]                                                      │
│                                                          │
│  ⚠️  所有都指向同一个目标 → ELK 有重排自由度            │
│                                                          │
└──────────────────────────────────────────────────────────┘
                           ↓
┌──────────────────────────────────────────────────────────┐
│ 第 3 步：ELK 布局计算                                    │
├──────────────────────────────────────────────────────────┤
│                                                          │
│  当前策略：LINEAR_SEGMENTS + EDGE_LENGTH                │
│                                                          │
│  ELK 的思路：                                           │
│  1. 识别所有节点在同一层                                │
│  2. 没有收到排序信息 ❌                                  │
│  3. 应用 LINEAR_SEGMENTS 策略                           │
│  4. 为了最小化边交叉而重排节点                          │
│  5. 最后的节点可能被优化到最上面                        │
│                                                          │
│  ❌ 输出顺序改变                                        │
│                                                          │
└──────────────────────────────────────────────────────────┘
                           ↓
┌──────────────────────────────────────────────────────────┐
│ 第 4 步：React Flow 渲染                                │
├──────────────────────────────────────────────────────────┤
│                                                          │
│  elkOutput = [                                          │
│    { id: "input-totalUnsettlement", y: 0 },    ← 最后  │
│    { id: "input-USDCHolding", y: 150 },                 │
│    { id: "array-nonUSDCHolding", y: 300 }     ← 第一   │
│  ]                                                      │
│                                                          │
│  ❌ 显示顺序与定义顺序相反！                            │
│                                                          │
└──────────────────────────────────────────────────────────┘
```

---

## 🔧 修复过程

```
┌──────────────────────────────────────────────────────────┐
│ 修复步骤 1：创建排序映射                                │
├──────────────────────────────────────────────────────────┤
│                                                          │
│  inputNodeOrder = Map {                                 │
│    "array-nonUSDCHolding" → 0                           │
│    "input-USDCHolding" → 1                              │
│    "input-totalUnsettlement" → 2                        │
│  }                                                      │
│                                                          │
│  ✅ 记录原始顺序                                        │
│                                                          │
└──────────────────────────────────────────────────────────┘
                           ↓
┌──────────────────────────────────────────────────────────┐
│ 修复步骤 2：添加排序权重约束                            │
├──────────────────────────────────────────────────────────┤
│                                                          │
│  elkNode.layoutOptions = {                              │
│    "priority.weight": "0"      ← node 0 (最高优先级)    │
│    "priority.weight": "1000"   ← node 1                 │
│    "priority.weight": "2000"   ← node 2 (最低优先级)    │
│  }                                                      │
│                                                          │
│  ✅ 告诉 ELK 应该的排序                                │
│                                                          │
└──────────────────────────────────────────────────────────┘
                           ↓
┌──────────────────────────────────────────────────────────┐
│ 修复步骤 3：改变 ELK 策略                               │
├──────────────────────────────────────────────────────────┤
│                                                          │
│  layoutOptions = {                                      │
│    "nodePlacement.strategy": "SIMPLE",                  │
│      ↑ 更严格地遵守排序约束                             │
│                                                          │
│    "compaction.strategy": "LEFT",                       │
│      ↑ 保持左对齐和相对位置                             │
│                                                          │
│    "mergeEdges": "false",                               │
│      ↑ 禁用可能打乱顺序的优化                           │
│  }                                                      │
│                                                          │
│  ✅ ELK 尊重排序约束                                    │
│                                                          │
└──────────────────────────────────────────────────────────┘
                           ↓
┌──────────────────────────────────────────────────────────┐
│ 结果：ELK 按权重排序                                    │
├──────────────────────────────────────────────────────────┤
│                                                          │
│  elkOutput = [                                          │
│    { id: "array-nonUSDCHolding", y: 100 },   ← weight 0 │
│    { id: "input-USDCHolding", y: 240 },     ← weight 1k │
│    { id: "input-totalUnsettlement", y: 370 } ← weight 2k│
│  ]                                                      │
│                                                          │
│  ✅ 顺序正确，Y 坐标递增！                              │
│                                                          │
└──────────────────────────────────────────────────────────┘
```

---

## 📊 策略对比

### LINEAR_SEGMENTS（当前 ❌）

```
优点：
  ✓ 试图创建线性排列
  ✓ 最小化边交叉

缺点：
  ✗ 不保证保留顺序
  ✗ 为了优化可能重排节点
  ✗ 最后导致乱序
```

### SIMPLE（修复后 ✅）

```
优点：
  ✓ 严格遵守排序约束
  ✓ 保留节点顺序
  ✓ 尊重 priority.weight

缺点：
  (基本没有)
```

---

## 🎯 权重计算示例

```
3 个输入节点的权重分配：

┌─────────────────────────────────────┐
│ 创建 inputNodeOrder 映射            │
├─────────────────────────────────────┤
│                                     │
│ nodes.forEach((node, index) => {    │
│   if (node.type === "input") {      │
│     inputNodeOrder.set(               │
│       node.id,  // "input-xxx"      │
│       inputIndex++  // 0, 1, 2, ... │
│     )                               │
│   }                                 │
│ })                                  │
│                                     │
├─────────────────────────────────────┤
│ 结果：                              │
│ Map {                               │
│   "array-nonUSDCHolding" => 0       │
│   "input-USDCHolding" => 1          │
│   "input-totalUnsettlement" => 2    │
│ }                                   │
│                                     │
└─────────────────────────────────────┘
            ↓
┌─────────────────────────────────────┐
│ 计算权重：priority * 1000            │
├─────────────────────────────────────┤
│                                     │
│ priority.weight = 0 * 1000   = 0    │
│ priority.weight = 1 * 1000   = 1000 │
│ priority.weight = 2 * 1000   = 2000 │
│                                     │
└─────────────────────────────────────┘
            ↓
┌─────────────────────────────────────┐
│ ELK 排序（权重越小越靠前）          │
├─────────────────────────────────────┤
│                                     │
│ weight=0    node 0 ← 最上面         │
│ weight=1k   node 1                  │
│ weight=2k   node 2 ← 最下面         │
│                                     │
└─────────────────────────────────────┘
```

---

## ✅ 成功标志

修复完成后，应该看到：

```
控制台输出：
[0] array-nonUSDCHolding: y=100
[1] input-USDCHolding: y=240
[2] input-totalUnsettlement: y=370

✓ Y 坐标严格递增（100 < 240 < 370）
✓ 顺序与定义顺序一致
✓ 第一项在最上面
✓ 最后一项在最下面
```

---

## 🔍 调试检查清单

```
□ inputNodeOrder 是否被正确填充？
  console.log("inputNodeOrder:", inputNodeOrder);

□ 每个 elkNode 是否都有 layoutOptions？
  console.log("elkNode:", elkNode);

□ ELK layoutOptions 是否被正确修改？
  console.log("graph.layoutOptions:", graph.layoutOptions);

□ 最终节点 Y 坐标是否严格递增？
  nodes
    .filter(n => n.type === "input")
    .sort((a, b) => a.position.y - b.position.y)
    .forEach(n => console.log(`${n.id}: y=${n.position.y}`));
```

---

## 📈 改进对比表

| 指标       | 修复前        | 修复后      |
| ---------- | ------------- | ----------- |
| Y 坐标顺序 | 随机/乱序     | 严格递增 ✅ |
| 最后项位置 | 最上面 ❌     | 最下面 ✅   |
| 顺序一致性 | 与定义不同 ❌ | 完全一致 ✅ |
| 视觉表现   | 混乱          | 清晰        |
| 用户体验   | 困惑          | 直观        |

---

**总结**：通过改变 ELK 策略 + 添加排序约束，我们从 ELK 的自由重排中夺回了对节点顺序的控制，确保布局符合定义顺序。

🎉 **修复完成！**
