[
  {
    "id": "totalValue",
    "name": "Total Value",
    "version": "1.0.0",
    "description": "## Definition\n\n**Total Value** = User's total asset value (denominated in USDC), including assets that cannot be used as collateral\n\n**Total holding** = Sum of all holding quantities in the user's account\n\n**usdc balance.holding** = USDC holding quantity\n\n**non-usdc balance.holding * mark price** = Value of non-USDC asset holdings (denominated in USDC)\n\n**holding**: Asset quantity held by the user, from `/v1/client/holding` or v2 Websocket API | Balance\n\n**mark price**: Current price of the asset, from v2 Websocket API | Balance\n\n**total unsettlement PNL** = Sum of user's account unsettled PNL\n\n## Example\n\n```\ntotal_holding = 2000 + 1000 * 1.001 = 3001\nTotal Value = 3001 - 18.34 = 2982.66\ntotal unsettlement PNL = -18.34\n```",
    "formula": "Total Value = total_holding + total unsettlement PNL, total_holding = usdc balance.holding + SUM(non-usdc balance.holding * mark price)",
    "inputs": [
      {
        "key": "inputs",
        "type": "object",
        "factorType": {
          "baseType": "object",
          "constraints": {},
          "nullable": false,
          "array": false,
          "properties": [
            {
              "key": "totalUnsettlementPnL",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              }
            },
            {
              "key": "USDCHolding",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              }
            },
            {
              "key": "nonUSDCHolding",
              "type": "object",
              "factorType": {
                "baseType": "object",
                "nullable": false,
                "array": true,
                "properties": [
                  {
                    "key": "holding",
                    "type": "number",
                    "factorType": {
                      "baseType": "number",
                      "nullable": false,
                      "array": false
                    }
                  },
                  {
                    "key": "indexPrice",
                    "type": "number",
                    "factorType": {
                      "baseType": "number",
                      "nullable": false,
                      "array": false
                    }
                  }
                ]
              }
            }
          ]
        }
      }
    ],
    "outputs": [
      {
        "key": "result",
        "type": "number",
        "factorType": {
          "baseType": "number",
          "nullable": false,
          "array": false
        }
      }
    ],
    "formulaText": "{\n  const { totalUnsettlementPnL, USDCHolding, nonUSDCHolding } = inputs;\n  const nonUSDCHoldingValue = nonUSDCHolding.reduce((acc, cur) => {\n    return new Decimal(cur.holding).mul(cur.indexPrice).add(acc);\n  }, zero);\n  return nonUSDCHoldingValue.add(USDCHolding).add(totalUnsettlementPnL);\n}",
    "sourceCode": "export function totalValue(inputs: TotalValueInputs): Decimal {\n  const { totalUnsettlementPnL, USDCHolding, nonUSDCHolding } = inputs;\n  const nonUSDCHoldingValue = nonUSDCHolding.reduce((acc, cur) => {\n    return new Decimal(cur.holding).mul(cur.indexPrice).add(acc);\n  }, zero);\n  return nonUSDCHoldingValue.add(USDCHolding).add(totalUnsettlementPnL);\n}",
    "localNpmInfo": {
      "packageName": "@orderly.network/perp",
      "functionName": "totalValue",
      "enabled": true
    }
  },
  {
    "id": "freeCollateral",
    "name": "Free Collateral",
    "version": "1.0.0",
    "description": "## Definition\n\n**Free collateral**: Total value of available margin in the user's account (denominated in USDC)\n\n**Total_collateral_value**: Total value of collateral assets in the user's account (denominated in USDC)\n\n**total_initial_margin_with_orders**: Total initial margin used by the user (including positions and orders)\n\n**initial_margin_i with order**: Initial margin for symbol i (considering both positions and orders)\n\n**IMR_i (with_orders)**: Initial margin rate for a single symbol (considering both position and order notional)\n\n**Max Account Leverage**: Maximum leverage set by the user, from `/v1/client/info.max_leverage`\n\n**Base IMR i**: Base initial margin rate for a single symbol, from `/v1/public/info`\n\n**IMR Factor i**: IMR calculation factor for a single symbol, from `v1/client/info`\n\n**Position Notional i**: Sum of position notional for a single symbol\n\n**Order Notional i**: Sum of order notional for a single symbol\n\n**position_notional_with_orders_i**: Sum of position and order notional for a single symbol\n\n**mark_price_i**: Mark price for a single symbol\n\n**position_qty_with_orders_i**: Sum of position and order quantity for a single symbol\n\n**position_qty_i**: Position quantity for a single symbol\n\n**sum_position_qty_buy_orders_i**: Sum of long order quantity for a single symbol [algo orders should be ignored]\n\n**sum_position_qty_sell_orders_i**: Sum of short order quantity for a single symbol [algo orders should be ignored]\n\n## Example\n\n```\nBTC-PERP position_qty_with_orders_i = max[ abs(0.2+0.3) , abs(0.2-0.5) ] = 0.5\nETH-PERP position_qty_with_orders_i = max[ abs(-3+0), abs(-3+0)] = 3\n\nBTC-PERP position_notional_with_orders_i = 0.5 * 25986.2 = 12993.1\nETH-PERP position_notional_with_orders_i = 3 * 1638.41 = 4915.23\n\nBTC-PERP IMR_i (with_orders) = Max(\n  1 / Max Account Leverage = 1 / 10 = 0.1\n  Base IMR i = 0.1\n  IMR Factor i * Abs(Position Notional i + Order Notional i)^(4/5)) = 0.0000002512 * Abs(5197.2 + 7200 - 14000)^(4/5) = 9.20286609e-5\n) = 0.1\n\nETH-PERP IMR_i (with_orders) = Max(\n  1 / Max Account Leverage = 1 / 10 = 0.1\n  Base IMR i = 0.1\n  IMR Factor i * Abs(Position Notional i + Order Notional i)^(4/5)) = 0.0000003754 * Abs(-4915.23)^(4/5) = 0.00649875988\n) = 0.1\n\ntotal_initial_margin_with_orders = 12993.1 * 0.1 + 4915.23 * 0.1 = 1790.833\nTotal_collateral_value = 1981.66\nFree Collateral = 1981.66 - 1790.833 = 190.82700\n```",
    "formula": "Free Collateral = Total_collateral_value - total_initial_margin_with_orders,Total_collateral_value,\ntotal_initial_margin_with_orders = sum ( position_notional_with_orders_i * IMR_i (with_orders)),\nIMR_i (with_orders) = Max(1 / Max Account Leverage, Base IMR i, IMR Factor i * Abs(Position Notional i + Order Notional i)^(4/5)),\nposition_notional_with_orders_i = abs( mark_price_i * position_qty_with_orders_i),\nposition_qty_with_orders_i = max[ abs(position_qty_i + sum_position_qty_buy_orders_i), abs(position_qty_i - sum_position_qty_sell_orders_i)]",
    "inputs": [
      {
        "key": "inputs",
        "type": "object",
        "factorType": {
          "baseType": "object",
          "constraints": {},
          "nullable": false,
          "array": false,
          "properties": [
            {
              "key": "totalCollateral",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              }
            },
            {
              "key": "totalInitialMarginWithOrders",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              }
            }
          ]
        }
      }
    ],
    "outputs": [
      {
        "key": "result",
        "type": "number",
        "factorType": {
          "baseType": "number",
          "nullable": false,
          "array": false
        }
      }
    ],
    "formulaText": "{\n  const value = inputs.totalCollateral.sub(inputs.totalInitialMarginWithOrders);\n  // free collateral cannot be less than 0\n  return value.isNegative() ? zero : value;\n}",
    "sourceCode": "export function freeCollateral(inputs: FreeCollateralInputs): Decimal {\n  const value = inputs.totalCollateral.sub(inputs.totalInitialMarginWithOrders);\n  // free collateral cannot be less than 0\n  return value.isNegative() ? zero : value;\n}",
    "localNpmInfo": {
      "packageName": "@orderly.network/perp",
      "functionName": "freeCollateral",
      "enabled": true
    }
  },
  {
    "id": "totalCollateral",
    "name": "Total Collateral",
    "version": "1.0.0",
    "description": "## Definition\n\n**discount**: Collateral substitution rate\n\n**Total collateral**: Total value of collateral assets in the user's account (denominated in USDC)\n\n**usdc balance.holding**: USDC holding quantity\n\n**non-usdc balance.holding * mark price**: Value of non-USDC asset holdings (denominated in USDC)\n\n**holding**: Asset quantity held by the user, from `/v1/client/holding` or v2 Websocket API | Balance\n\n**mark price**: Current price of the asset, from v2 Websocket API | Balance\n\n**total unsettlement PNL**: Sum of user's account unsettled PNL\n\n## Example\n\n```\nTotal collateral = 2000 + 1000 * 1.001 * 0 - 18.34 = 1981.66\ntotal unsettlement PNL = -18.34\n```",
    "formula": "Total collateral = usdc balance.holding + SUM(non-usdc balance.holding * mark price * discount) + total unsettlement PNL",
    "inputs": [
      {
        "key": "inputs",
        "type": "object",
        "factorType": {
          "baseType": "object",
          "constraints": {},
          "nullable": false,
          "array": false,
          "properties": [
            {
              "key": "USDCHolding",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              }
            },
            {
              "key": "nonUSDCHolding",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": true
              }
            },
            {
              "key": "unsettlementPnL",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              },
              "description": "\nSum of user's account unsettled PNL"
            }
          ]
        }
      }
    ],
    "outputs": [
      {
        "key": "result",
        "type": "number",
        "factorType": {
          "baseType": "number",
          "nullable": false,
          "array": false
        }
      }
    ],
    "formulaText": "{\n  const { USDCHolding, nonUSDCHolding, unsettlementPnL } = inputs;\n  const nonUSDCHoldingValue = nonUSDCHolding.reduce<Decimal>((acc, cur) => {\n    const finalHolding = Math.min(cur.holding, cur.collateralCap);\n    const value = new Decimal(finalHolding)\n      .mul(cur.collateralRatio)\n      .mul(cur.indexPrice);\n    return acc.add(value);\n  }, zero);\n\n  return new Decimal(USDCHolding).add(nonUSDCHoldingValue).add(unsettlementPnL);\n}",
    "sourceCode": "export function totalCollateral(inputs: TotalCollateralValueInputs): Decimal {\n  const { USDCHolding, nonUSDCHolding, unsettlementPnL } = inputs;\n  const nonUSDCHoldingValue = nonUSDCHolding.reduce<Decimal>((acc, cur) => {\n    const finalHolding = Math.min(cur.holding, cur.collateralCap);\n    const value = new Decimal(finalHolding)\n      .mul(cur.collateralRatio)\n      .mul(cur.indexPrice);\n    return acc.add(value);\n  }, zero);\n\n  return new Decimal(USDCHolding).add(nonUSDCHoldingValue).add(unsettlementPnL);\n}",
    "localNpmInfo": {
      "packageName": "@orderly.network/perp",
      "functionName": "totalCollateral",
      "enabled": true
    }
  },
  {
    "id": "imr",
    "name": "IMR",
    "version": "1.0.0",
    "description": "Initial margin rate for a symbol.\nMax(1 / Max Account Leverage, Base IMR i, IMR Factor i * Abs(Position Notional i + Order Notional i)^(4/5))",
    "inputs": [
      {
        "key": "inputs",
        "type": "object",
        "factorType": {
          "baseType": "object",
          "constraints": {},
          "nullable": false,
          "array": false,
          "properties": [
            {
              "key": "maxLeverage",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              },
              "description": "\neffective max leverage"
            },
            {
              "key": "baseIMR",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              }
            },
            {
              "key": "IMR_Factor",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              }
            },
            {
              "key": "positionNotional",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              }
            },
            {
              "key": "ordersNotional",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              }
            },
            {
              "key": "IMR_factor_power",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": true,
                "array": false
              }
            }
          ]
        }
      }
    ],
    "outputs": [
      {
        "key": "result",
        "type": "number",
        "factorType": {
          "baseType": "number",
          "nullable": false,
          "array": false
        }
      }
    ],
    "formulaText": "{\n  const {\n    maxLeverage,\n    baseIMR,\n    IMR_Factor,\n    positionNotional,\n    ordersNotional: orderNotional,\n    IMR_factor_power = IMRFactorPower,\n  } = inputs;\n  return Math.max(\n    1 / maxLeverage,\n    baseIMR,\n    new Decimal(IMR_Factor)\n      .mul(\n        new Decimal(positionNotional)\n          .add(orderNotional)\n          .abs()\n          .toPower(IMR_factor_power),\n      )\n      .toNumber(),\n  );\n}",
    "sourceCode": "export function IMR(inputs: IMRInputs): number {\n  const {\n    maxLeverage,\n    baseIMR,\n    IMR_Factor,\n    positionNotional,\n    ordersNotional: orderNotional,\n    IMR_factor_power = IMRFactorPower,\n  } = inputs;\n  return Math.max(\n    1 / maxLeverage,\n    baseIMR,\n    new Decimal(IMR_Factor)\n      .mul(\n        new Decimal(positionNotional)\n          .add(orderNotional)\n          .abs()\n          .toPower(IMR_factor_power),\n      )\n      .toNumber(),\n  );\n}",
    "localNpmInfo": {
      "packageName": "@orderly.network/perp",
      "functionName": "IMR",
      "enabled": true
    }
  },
  {
    "id": "maxQty",
    "name": "Max Order QTY",
    "version": "1.0.0",
    "description": "## Max Long Quantity Formula\n\n```\nmax long qty = MIN (\n  base max,\n  (((Total_collateral_value - Other_IMs) / (Max(1 / Max Account Leverage, Base IMR i) + 2 * futures_take_fee_rate * 0.0001) / mark_price_i) * 0.995 - position_qty_this_symbol - sum_buy_order_qty_this_symbol),\n  ((((Total_collateral_value - Other_IMs) / IMR Factor i)^(1/1.8)) / mark_price_i - position_qty_this_symbol - sum_buy_order_qty_this_symbol) / (1 + 2 * futures_take_fee_rate * 0.0001) * 0.995\n)\n```\n\n## Max Short Quantity Formula\n\n```\nmax short qty = MIN (\n  base max,\n  (((Total_collateral_value - Other_IMs) / (Max(1 / Max Account Leverage, Base IMR i) + 2 * futures_take_fee_rate * 0.0001) / mark_price_i) * 0.995 + position_qty_this_symbol - sum_sell_order_qty_this_symbol),\n  ((((Total_collateral_value - Other_IMs) / IMR Factor i)^(1/1.8)) / mark_price_i + position_qty_this_symbol - sum_sell_order_qty_this_symbol) / (1 + 2 * futures_take_fee_rate * 0.0001) * 0.995\n)\n```\n\n## Reduce Only Mode\n\nWhen reduce only is enabled:\n- If `position_qty_i > 0`: max long qty = 0, max short qty = abs(position_qty_i)\n- If `position_qty_i < 0`: max long qty = abs(position_qty_i), max short qty = 0\n- If `position_qty_i = 0`: max long qty = 0, max short qty = 0\n\n## Variable Definitions\n\n| Variable | Description | API Reference |\n|----------|-------------|---------------|\n| `max long qty` | Maximum long quantity for current symbol | |\n| `max short qty` | Maximum short quantity for current symbol | |\n| `base_max` | Maximum quantity limit for opening a single position | `/v1/public/info.base_max` |\n| `Total_collateral_value` | Total value of collateral assets in user account (USDC denominated) | |\n| `Other_IMs` | Initial margin occupied by all other symbols excluding current symbol | |\n| `IMR_i (with_orders)` | Initial margin rate for a single symbol (considering both position/orders notional) | |\n| `Max Account Leverage` | Maximum leverage set by user | `/v1/client/info.max_leverage` |\n| `Base IMR i` | Base initial margin rate for a single symbol | `/v1/public/info` |\n| `IMR Factor i` | IMR calculation factor for a single symbol | `v1/client/info` |\n| `Position Notional i` | Sum of position notional for a single symbol | |\n| `Order Notional i` | Sum of order notional for a single symbol | |\n| `position_notional_with_orders_i` | Sum of position/orders notional for a single symbol | |\n| `mark_price_i` | Mark price for a single symbol | |\n| `position_qty_with_orders_i` | Sum of position/orders quantity for a single symbol | |\n| `position_qty_i` | Position quantity for a single symbol | |\n| `sum_position_qty_buy_orders_i` | Sum of long order quantity for a single symbol [algo orders ignored] | |\n| `sum_position_qty_sell_orders_i` | Sum of short order quantity for a single symbol [algo orders ignored] | |\n| `futures_take_fee_rate` | User's futures taker fee rate | `GET /v1/client/info` |\n\n## Calculation Details\n\n```\nOther_IMs = sum(position_notional_with_orders_i * IMR_i (with_orders)) // excluding current symbol\n\nIMR_i (with_orders) = Max(1 / Max Account Leverage, Base IMR i, IMR Factor i * Abs(Position Notional i + Order Notional i)^(4/5))\n\nposition_notional_with_orders_i = abs(mark_price_i * position_qty_with_orders_i)\n\nposition_qty_with_orders_i = max[abs(position_qty_i + sum_position_qty_buy_orders_i), abs(position_qty_i - sum_position_qty_sell_orders_i)]\n```\n\n## Example Calculation\n\n**Given:**\n- `futures_take_fee_rate = 8`\n- `BTC base max = 20`\n- `Total_collateral_value = 1981.66`\n- `Other_IMs = ETH Initial Margin = 4915.23 * 0.1 = 491.523`\n- `BTC mark_price_i = 25986.2`\n- `BTC position_qty_this_symbol = 0.2`\n- `sum_buy_order_qty_this_symbol = 0.3`\n- `sum_sell_order_qty_this_symbol = -0.5`\n\n**Max Long Quantity:**\n```\nmax long qty = MIN(\n  20 BTC,\n  ((1981.66 - 491.523) / (0.1 + 2 * 8 * 0.0001) / 25986.2 * 0.995 - 0.2 - 0.3) = 0.0615815026 BTC,\n  ((((1981.66 - 491.523) / 0.0000002512)^(1/1.8)) / 25986.2 - 0.2 - 0.3) / (1 + 2 * 8 * 0.0001) * 0.995 = 9.78216039 BTC\n) = 0.0615815026 BTC\n```\n\n**Max Short Quantity:**\n```\nmax short qty = MIN(\n  20 BTC,\n  ((1981.66 - 491.523) / (0.1 + 2 * 8 * 0.0001) / 25986.2 * 0.995 + 0.2 - 0.5) = 0.261581503 BTC,\n  ((((1981.66 - 491.523) / 0.0000002512)^(1/1.8)) / 25986.2 + 0.2 - 0.5) / (1 + 2 * 8 * 0.0001) * 0.995 = 9.98084249726 BTC\n) = 0.261581503 BTC\n```\n\n## Additional Examples\n\n**Base max qty calculation:**\n```\nBase max qty = (1981.66 - 491.523) / (0.1 + 2 * 8 * 0.0001) / 25986.2 * 0.995 = 0.561581503 BTC\n```\n\n**Different position scenarios:**\n\n1. **Short position -0.3 BTC:**\n   - max long qty = 0.561581503 - (-0.3) = 0.861581503\n   - max short qty = 0.561581503 + (-0.3) = 0.261581503\n\n2. **Short position -0.3 BTC + sell orders 0.1:**\n   - max long qty = 0.561581503 - (-0.3) = 0.861581503\n   - max short qty = 0.561581503 + (-0.3) - 0.1 = 0.161581503\n\n3. **Long position 0.3 BTC + buy orders 0.2 + sell orders 0.1:**\n   - max long qty = 0.561581503 - 0.3 - 0.2 = 0.061581503\n   - max short qty = 0.561581503 + 0.3 - 0.1 = 0.761581503\n\n## Special Case: Insufficient Collateral\n\nWhen `totalCollatValue <= newTotalIM`:\n\n```\nnewOrderSize_iter = ITERATE() return max(0, newOrderSize_iter * 99.5% + others)\n```\n\n**ITERATE() Algorithm:**\n```\nITERATE() {\n    iteratorLeverage = min(1 / Max Account Leverage, Base IMR i)\n    iteratorStep = 2\n\n    // First iteration (30 times)\n    for (i = 0; i < 30; i++) {\n        iteratorLeverage = max(0, iteratorLeverage - iteratorStep)\n        newOrderSize1 = (adjustedCollateral - othersIM) * iteratorLeverage / markPrice\n        calculate afterTradeIM\n        if (adjustedCollateral >= afterTradeIM) break\n    }\n\n    leftLeverage = iteratorLeverage\n    rightLeverage = min(maxLeverage_account, leftLeverage + iteratorStep)\n\n    // Binary search (30 times)\n    for (i = 0; i < 30; i++) {\n        midLeverage = (leftLeverage + rightLeverage) / 2\n        newOrderSize2 = (adjustedCollateral - othersIM) * midLeverage / markPrice\n        calculate afterTradeIM\n        precision = (adjustedCollateral - afterTradeIM) / adjustedCollateral\n\n        if (adjustedCollateral > afterTradeIM) {\n            leftLeverage = midLeverage\n            if (0 <= precision <= 0.5%) break\n        } else {\n            rightLeverage = midLeverage\n        }\n    }\n\n    return newOrderSize2\n}\n```",
    "inputs": [
      {
        "key": "side",
        "type": "number",
        "factorType": {
          "baseType": "number",
          "constraints": {},
          "nullable": false,
          "array": false
        }
      },
      {
        "key": "inputs",
        "type": "object",
        "factorType": {
          "baseType": "object",
          "constraints": {},
          "nullable": false,
          "array": false,
          "properties": [
            {
              "key": "symbol",
              "type": "string",
              "factorType": {
                "baseType": "string",
                "nullable": false,
                "array": false
              }
            },
            {
              "key": "baseMaxQty",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              }
            },
            {
              "key": "totalCollateral",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              },
              "description": "\nTotal collateral of the user (denominated in USDC), can be calculated from totalCollateral."
            },
            {
              "key": "maxLeverage",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              }
            },
            {
              "key": "baseIMR",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              }
            },
            {
              "key": "otherIMs",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              }
            },
            {
              "key": "markPrice",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              }
            },
            {
              "key": "positionQty",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              }
            },
            {
              "key": "buyOrdersQty",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              }
            },
            {
              "key": "sellOrdersQty",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              }
            },
            {
              "key": "IMR_Factor",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              }
            },
            {
              "key": "takerFeeRate",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              }
            }
          ]
        }
      },
      {
        "key": "options",
        "type": "object",
        "factorType": {
          "baseType": "object",
          "constraints": {},
          "nullable": true,
          "array": false
        }
      }
    ],
    "outputs": [
      {
        "key": "result",
        "type": "number",
        "factorType": {
          "baseType": "number",
          "nullable": false,
          "array": false
        }
      }
    ],
    "formulaText": "{\n  if (side === OrderSide.BUY) {\n    return maxQtyByLong(inputs);\n  }\n  return maxQtyByShort(inputs);\n}",
    "sourceCode": "export function maxQty(\n  side: OrderSide,\n  inputs: MaxQtyInputs,\n  options?: ResultOptions,\n): number {\n  if (side === OrderSide.BUY) {\n    return maxQtyByLong(inputs);\n  }\n  return maxQtyByShort(inputs);\n}",
    "localNpmInfo": {
      "packageName": "@orderly.network/perp",
      "functionName": "maxQty",
      "enabled": true
    }
  },
  {
    "id": "totalUnrealizedROI",
    "name": "Total Unrealized ROI",
    "version": "1.0.0",
    "description": "## Definition\n\n**Total Unrealized PNL** = Sum of unrealized profit and loss for all current positions of the user\n\n**Total Value** = User's total asset value (denominated in USDC), including assets that cannot be used as collateral\n\n## Example\n\n```\nTotal Unrealized ROI = 200.53 / ( 2982.66 - 200.53 ) * 100% = 7.21%\nTotal Unrealized PNL = 200.53\nTotal Value = 2982.66\n```",
    "formula": "Total Unrealized ROI = Total Unrealized PNL / ( Total Value - Total Unrealized PNL ) * 100%",
    "inputs": [
      {
        "key": "inputs",
        "type": "object",
        "factorType": {
          "baseType": "object",
          "constraints": {},
          "nullable": false,
          "array": false,
          "properties": [
            {
              "key": "totalUnrealizedPnL",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              }
            },
            {
              "key": "totalValue",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              }
            }
          ]
        }
      }
    ],
    "outputs": [
      {
        "key": "result",
        "type": "number",
        "factorType": {
          "baseType": "number"
        }
      }
    ],
    "formulaText": "{\n  const { totalUnrealizedPnL, totalValue } = inputs;\n\n  return new Decimal(totalUnrealizedPnL)\n    .div(totalValue - totalUnrealizedPnL)\n    .toNumber();\n}",
    "sourceCode": "export function totalUnrealizedROI(inputs: TotalUnrealizedROIInputs) {\n  const { totalUnrealizedPnL, totalValue } = inputs;\n\n  return new Decimal(totalUnrealizedPnL)\n    .div(totalValue - totalUnrealizedPnL)\n    .toNumber();\n}",
    "localNpmInfo": {
      "packageName": "@orderly.network/perp",
      "functionName": "totalUnrealizedROI",
      "enabled": true
    }
  },
  {
    "id": "mmr",
    "name": "Total Maintenance Margin Ratio",
    "version": "1.0.0",
    "description": "## Definition\n\n**Total Maintenance Margin Ratio** = User's account maintenance margin ratio\n\n**sum(Position maintenance margin)** = Total maintenance margin of all user positions (denominated in USDC)\n\n**total_position_notional** = Sum of notional value of current positions\n\n**position_qty_i** = Position quantity for a single symbol\n\n**mark_price_i** = Mark price for a single symbol\n\n## Example\n\n```\nTotal Margin Ratio = 505.61 / 10112.43 * 100% = 4.99988628%\ntotal_position_notional = 10112.43\nabs(BTC position notional) = 5197.2\nabs(ETH position notional) = 4915.23\nsum(Position maintenance margin) = 505.61\nBTC position MM = 259.86\nETH position MM = 245.75\n```",
    "formula": "Total Maintenance Margin Ratio = sum(Position maintenance margin) / total_position_notional * 100%, total_position_notional = sum(abs(position_qty_i * mark_price_i))",
    "inputs": [
      {
        "key": "inputs",
        "type": "object",
        "factorType": {
          "baseType": "object",
          "constraints": {},
          "nullable": false,
          "array": false,
          "properties": [
            {
              "key": "positionsMMR",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              }
            },
            {
              "key": "positionsNotional",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              },
              "description": "\nNotional sum of all positions,\npositions.totalNotional()"
            }
          ]
        }
      }
    ],
    "outputs": [
      {
        "key": "result",
        "type": "number",
        "factorType": {
          "baseType": "number",
          "nullable": true,
          "array": false
        },
        "description": "number|null"
      }
    ],
    "formulaText": "{\n  // If the user does not have any positions, return null\n  if (inputs.positionsNotional === 0) {\n    return null;\n  }\n  if (inputs.positionsMMR === 0) {\n    return null;\n  }\n  return new Decimal(inputs.positionsMMR)\n    .div(inputs.positionsNotional)\n    .toNumber();\n}",
    "sourceCode": "export function MMR(inputs: AccountMMRInputs): number | null {\n  // If the user does not have any positions, return null\n  if (inputs.positionsNotional === 0) {\n    return null;\n  }\n  if (inputs.positionsMMR === 0) {\n    return null;\n  }\n  return new Decimal(inputs.positionsMMR)\n    .div(inputs.positionsNotional)\n    .toNumber();\n}",
    "localNpmInfo": {
      "packageName": "@orderly.network/perp",
      "functionName": "MMR",
      "enabled": true
    }
  },
  {
    "id": "estLiqPrice",
    "name": "Est. Position liq. Price",
    "version": "1.0.0",
    "description": "## When user has positions:\n\n```\nEst. liq. Position Price = max(mark_price_i + (total_collateral_value - new_total_MM - order_fee) / (abs(position_qty_i + new_order_qty_i) * new_MMRi - (position_qty_i + new_order_qty_i)), 0)\n```\n\n## When user has no positions:\n\n```\nEst. liq. Position Price = max(order_price_i + (total_collateral_value - new_total_MM - order_fee) / (abs(position_qty_i + new_order_qty_i) * new_MMRi - (position_qty_i + new_order_qty_i)), 0)\n```\n\n## Formula Components:\n\n- `order_fee = new_order_qty_i * order_price_i * futures_take_fee_rate`\n- `new_total_MM = sum(abs(position_qty_i * mark_price_i + new_order_qty_i * order_price_i)) * MMRi)`\n- `new_MMRi = Max(Base_MMR_i, (Base_MMR_i / Base_IMR_i) * IMR_Factor_i * Abs(position_qty_i * mark_price_i + new_order_qty_i * limit_price_i)^(4/5))`\n\n## Order Price Determination:\n\n### Market Order:\n- **Long order**: `order_price_i = ask0`\n- **Short order**: `order_price_i = bid0`\n\n### Limit Order:\n\n#### Long order:\n- If `limit_price >= ask0`: `order_price_i = ask0`\n- If `limit_price < ask0`: `order_price_i = limit_price`\n\n#### Short order:\n- If `limit_price <= bid0`: `order_price_i = bid0`\n- If `limit_price > bid0`: `order_price_i = limit_price`\n\n## Parameter Definitions:\n\n| Parameter | Description |\n|-----------|-------------|\n| `Est. Position liq. Price` | Estimated liquidation price for the position |\n| `position_qty_i` | Position quantity for a single symbol |\n| `mark_price_i` | Mark price for a single symbol |\n| `total_collateral_value` | Total asset value of user's account margin (USDC denominated) |\n| `new_order_qty_i` | Symbol quantity when user prepares to open position (positive for long, negative for short) |\n| `new_total_MM` | Sum of current position maintenance margin (including prepared order maintenance margin) |\n| `new_MMR_i` | Maintenance margin rate for a single symbol (including prepared order notional consideration) |\n| `Base_MMR_i` | Base maintenance margin rate for a single symbol |\n| `Base_IMR_i` | Base initial margin rate for a single symbol |\n| `IMR_Factor_i` | IMR calculation factor for a single symbol, from v1/client/info |\n| `Position_Notional_i` | Sum of position notional for a single symbol |\n| `order_fee` | Estimated order fee when user prepares to open position |\n| `futures_take_fee_rate` | User's futures take fee rate, from GET /v1/client/info |\n| `order_price_i` | Estimated execution price when user prepares to open position |\n| `limit_price` | Price entered by user when preparing to open position |\n| `ask0` | Minimum ask price from orderbook |\n| `bid0` | Maximum bid price from orderbook |\n\n## Examples:\n\n### Market Order Example:\nLong BTC qty = 0.1, mark price = 25986.2, ask0 = 26000, BTC position_qty_i = 0.2, ETH position_qty_i = -3\nfutures_take_fee_rate = 0.06%\n\n**Result**: BTC Est. Position liq. Price = 21268.7316\n\n### Limit Order Example 1:\nLong BTC qty = 0.1, mark price = 25986.2, ask0 = 26000, limit price = 25000, BTC position_qty_i = 0.2, ETH position_qty_i = -3\n\n**Result**: BTC Est. Position liq. Price = 21250.9772\n\n### Limit Order Example 2:\nShort BTC qty = -0.1, mark price = 25986.2, bid0 = 25900, limit price = 25000, BTC position_qty_i = 0.2, ETH position_qty_i = -3\n\n**Result**: BTC Est. Position liq. Price = 9102.17368\n\n### No Position Example:\nLong BTC qty = 0.1, mark price = 25986.2, ask0 = 26000, limit price = 25000\n\n**Result**: BTC Est. Position liq. Price = 5472",
    "inputs": [
      {
        "key": "inputs",
        "type": "object",
        "factorType": {
          "baseType": "object",
          "constraints": {},
          "nullable": false,
          "array": false,
          "properties": [
            {
              "key": "totalCollateral",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              }
            },
            {
              "key": "markPrice",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              }
            },
            {
              "key": "baseMMR",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              }
            },
            {
              "key": "baseIMR",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              }
            },
            {
              "key": "IMR_Factor",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              }
            },
            {
              "key": "orderFee",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              }
            },
            {
              "key": "positions",
              "type": "object",
              "factorType": {
                "baseType": "object",
                "nullable": false,
                "array": true,
                "properties": [
                  {
                    "key": "position_qty",
                    "type": "number",
                    "factorType": {
                      "baseType": "number",
                      "nullable": false,
                      "array": false
                    }
                  },
                  {
                    "key": "mark_price",
                    "type": "number",
                    "factorType": {
                      "baseType": "number",
                      "nullable": false,
                      "array": false
                    }
                  },
                  {
                    "key": "symbol",
                    "type": "string",
                    "factorType": {
                      "baseType": "string",
                      "nullable": false,
                      "array": false
                    }
                  },
                  {
                    "key": "mmr",
                    "type": "number",
                    "factorType": {
                      "baseType": "number",
                      "nullable": false,
                      "array": false
                    }
                  }
                ]
              }
            },
            {
              "key": "newOrder",
              "type": "object",
              "factorType": {
                "baseType": "object",
                "nullable": false,
                "array": false,
                "properties": [
                  {
                    "key": "symbol",
                    "type": "string",
                    "factorType": {
                      "baseType": "string",
                      "nullable": false,
                      "array": false
                    }
                  },
                  {
                    "key": "qty",
                    "type": "number",
                    "factorType": {
                      "baseType": "number",
                      "nullable": false,
                      "array": false
                    }
                  },
                  {
                    "key": "price",
                    "type": "number",
                    "factorType": {
                      "baseType": "number",
                      "nullable": false,
                      "array": false
                    }
                  }
                ]
              }
            }
          ]
        }
      }
    ],
    "outputs": [
      {
        "key": "result",
        "type": "number",
        "factorType": {
          "baseType": "number",
          "nullable": false,
          "array": false
        }
      }
    ],
    "formulaText": "{\n  const {\n    positions,\n    newOrder,\n    totalCollateral,\n    markPrice,\n    baseIMR,\n    baseMMR,\n    orderFee,\n    IMR_Factor,\n  } = inputs;\n  // opened positions for the symbol\n  let currentPosition:\n    | Pick<\n        orderUtils.PositionExt,\n        \"position_qty\" | \"mark_price\" | \"symbol\" | \"mmr\"\n      >\n    | undefined = undefined;\n\n  let newTotalMM = zero;\n\n  const hasPosition =\n    positions.filter((item) => item.position_qty > 0).length > 0;\n\n  const basePrice = hasPosition ? markPrice : newOrder.price;\n\n  const newOrderNotional = new Decimal(newOrder.qty).mul(newOrder.price);\n\n  for (let index = 0; index < positions.length; index++) {\n    const position = positions[index];\n    let notional = new Decimal(position.position_qty).mul(position.mark_price);\n    if (newOrder.symbol === position.symbol) {\n      currentPosition = position;\n      notional = notional.add(newOrderNotional);\n    }\n\n    newTotalMM = newTotalMM.add(notional.abs().mul(position.mmr));\n  }\n\n  // if no position\n  if (!currentPosition) {\n    newTotalMM = newTotalMM.add(newOrderNotional.mul(baseMMR));\n  }\n\n  const newMMR = Math.max(\n    baseMMR,\n    new Decimal(baseMMR)\n      .div(baseIMR)\n      .mul(IMR_Factor)\n      .mul(\n        newOrderNotional\n          .add(\n            !!currentPosition\n              ? new Decimal(currentPosition.position_qty).mul(\n                  currentPosition.mark_price,\n                )\n              : zero,\n          )\n          .abs(),\n      )\n      .toPower(4 / 5)\n      .toNumber(),\n  );\n\n  // console.log(\"new MMR\", newMMR, newTotalMM.toNumber());\n\n  const newQty = new Decimal(newOrder.qty).add(\n    currentPosition?.position_qty ?? 0,\n  );\n\n  if (newQty.eq(0)) {\n    return 0;\n  }\n\n  const denominator = newQty.abs().mul(newMMR).sub(newQty);\n\n  if (denominator.eq(zero)) {\n    return 0;\n  }\n\n  const price = new Decimal(basePrice)\n    .add(\n      new Decimal(totalCollateral)\n        .sub(newTotalMM)\n        .sub(orderFee)\n        .div(denominator),\n    )\n    .toNumber();\n\n  return Math.max(0, price);\n}",
    "sourceCode": "export function estLiqPrice(inputs: EstimatedLiquidationPriceInputs): number {\n  const {\n    positions,\n    newOrder,\n    totalCollateral,\n    markPrice,\n    baseIMR,\n    baseMMR,\n    orderFee,\n    IMR_Factor,\n  } = inputs;\n  // opened positions for the symbol\n  let currentPosition:\n    | Pick<\n        orderUtils.PositionExt,\n        \"position_qty\" | \"mark_price\" | \"symbol\" | \"mmr\"\n      >\n    | undefined = undefined;\n\n  let newTotalMM = zero;\n\n  const hasPosition =\n    positions.filter((item) => item.position_qty > 0).length > 0;\n\n  const basePrice = hasPosition ? markPrice : newOrder.price;\n\n  const newOrderNotional = new Decimal(newOrder.qty).mul(newOrder.price);\n\n  for (let index = 0; index < positions.length; index++) {\n    const position = positions[index];\n    let notional = new Decimal(position.position_qty).mul(position.mark_price);\n    if (newOrder.symbol === position.symbol) {\n      currentPosition = position;\n      notional = notional.add(newOrderNotional);\n    }\n\n    newTotalMM = newTotalMM.add(notional.abs().mul(position.mmr));\n  }\n\n  // if no position\n  if (!currentPosition) {\n    newTotalMM = newTotalMM.add(newOrderNotional.mul(baseMMR));\n  }\n\n  const newMMR = Math.max(\n    baseMMR,\n    new Decimal(baseMMR)\n      .div(baseIMR)\n      .mul(IMR_Factor)\n      .mul(\n        newOrderNotional\n          .add(\n            !!currentPosition\n              ? new Decimal(currentPosition.position_qty).mul(\n                  currentPosition.mark_price,\n                )\n              : zero,\n          )\n          .abs(),\n      )\n      .toPower(4 / 5)\n      .toNumber(),\n  );\n\n  // console.log(\"new MMR\", newMMR, newTotalMM.toNumber());\n\n  const newQty = new Decimal(newOrder.qty).add(\n    currentPosition?.position_qty ?? 0,\n  );\n\n  if (newQty.eq(0)) {\n    return 0;\n  }\n\n  const denominator = newQty.abs().mul(newMMR).sub(newQty);\n\n  if (denominator.eq(zero)) {\n    return 0;\n  }\n\n  const price = new Decimal(basePrice)\n    .add(\n      new Decimal(totalCollateral)\n        .sub(newTotalMM)\n        .sub(orderFee)\n        .div(denominator),\n    )\n    .toNumber();\n\n  return Math.max(0, price);\n}",
    "localNpmInfo": {
      "packageName": "@orderly.network/perp",
      "functionName": "estLiqPrice",
      "enabled": true
    }
  },
  {
    "id": "totalNotional",
    "name": "Total Notional",
    "version": "1.0.0",
    "description": "## Term Definitions\n\n- **Total Notional**: Sum of current position notional values\n- **position_qty_i**: Single symbol position quantity\n- **mark_price_i**: Single symbol mark price\n\n## Example\n\n**Total Notional** = 10112.43\n\n**abs(BTC position notional)** = 5197.2\n\n**abs(ETH position notional)** = 4915.23",
    "formula": "Total Notional = sum ( abs(position_qty_i * mark_price_i) )",
    "inputs": [
      {
        "key": "positions",
        "type": "object",
        "factorType": {
          "baseType": "object",
          "constraints": {},
          "nullable": false,
          "array": true,
          "properties": [
            {
              "key": "account_id",
              "type": "string",
              "factorType": {
                "baseType": "string",
                "nullable": true,
                "array": false
              }
            },
            {
              "key": "symbol",
              "type": "string",
              "factorType": {
                "baseType": "string",
                "nullable": false,
                "array": false
              }
            },
            {
              "key": "position_qty",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              }
            },
            {
              "key": "cost_position",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              }
            },
            {
              "key": "last_sum_unitary_funding",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              }
            },
            {
              "key": "pending_long_qty",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              }
            },
            {
              "key": "pending_short_qty",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              }
            },
            {
              "key": "settle_price",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              }
            },
            {
              "key": "average_open_price",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              }
            },
            {
              "key": "unrealized_pnl",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              }
            },
            {
              "key": "unrealized_pnl_index",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": true,
                "array": false
              }
            },
            {
              "key": "unrealized_pnl_ROI",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              }
            },
            {
              "key": "unsettled_pnl",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              }
            },
            {
              "key": "unsettled_pnl_ROI",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              }
            },
            {
              "key": "unrealized_pnl_ROI_index",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": true,
                "array": false
              }
            },
            {
              "key": "mark_price",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              }
            },
            {
              "key": "index_price",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": true,
                "array": false
              }
            },
            {
              "key": "est_liq_price",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": true,
                "array": false
              }
            },
            {
              "key": "timestamp",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              }
            },
            {
              "key": "mmr",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              },
              "description": "\nMaintenance margin ratio"
            },
            {
              "key": "imr",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              }
            },
            {
              "key": "IMR_withdraw_orders",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              }
            },
            {
              "key": "MMR_with_orders",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              }
            },
            {
              "key": "pnl_24_h",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              }
            },
            {
              "key": "fee_24_h",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              }
            },
            {
              "key": "fundingFee",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": true,
                "array": false
              }
            },
            {
              "key": "leverage",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              }
            }
          ]
        }
      }
    ],
    "outputs": [
      {
        "key": "result",
        "type": "number",
        "factorType": {
          "baseType": "number",
          "nullable": false,
          "array": false
        },
        "description": "The total notional value of all positions."
      }
    ],
    "formulaText": "{\n  return positions.reduce((acc, cur) => {\n    return acc + notional(cur.position_qty, cur.mark_price);\n  }, 0);\n}",
    "sourceCode": "export function totalNotional(positions: API.Position[]): number {\n  return positions.reduce((acc, cur) => {\n    return acc + notional(cur.position_qty, cur.mark_price);\n  }, 0);\n}",
    "localNpmInfo": {
      "packageName": "@orderly.network/perp",
      "functionName": "totalNotional",
      "enabled": true
    }
  },
  {
    "id": "unrealizedPnL",
    "name": "unrealizedPnL",
    "version": "1.0.0",
    "description": "Calculates the unrealized profit or loss of a single position.",
    "formula": "qty * (markPrice - openPrice)",
    "inputs": [
      {
        "key": "inputs",
        "type": "object",
        "factorType": {
          "baseType": "object",
          "constraints": {},
          "nullable": false,
          "array": false,
          "properties": [
            {
              "key": "markPrice",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              },
              "description": "symbol mark price"
            },
            {
              "key": "openPrice",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              },
              "description": "symbol open price"
            },
            {
              "key": "qty",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              },
              "description": "symbol quantity"
            }
          ]
        }
      }
    ],
    "outputs": [
      {
        "key": "result",
        "type": "number",
        "factorType": {
          "baseType": "number",
          "nullable": false,
          "array": false
        },
        "description": "The unrealized profit or loss of the position."
      }
    ],
    "formulaText": "{\n  return new Decimal(inputs.qty)\n    .mul(inputs.markPrice - inputs.openPrice)\n    .toNumber();\n}",
    "sourceCode": "export function unrealizedPnL(inputs: UnrealPnLInputs): number {\n  return new Decimal(inputs.qty)\n    .mul(inputs.markPrice - inputs.openPrice)\n    .toNumber();\n}",
    "localNpmInfo": {
      "packageName": "@orderly.network/perp",
      "functionName": "unrealizedPnL",
      "enabled": true
    }
  },
  {
    "id": "unrealizedPnLROI",
    "name": "Position unrealized ROI",
    "version": "1.0.0",
    "description": "## Term Definitions\n\n- **Position unrealized ROI**: Single symbol unrealized return on investment\n- **Position unrealized PNL**: Single symbol unrealized profit and loss\n- **IMR_i**: Single symbol initial margin rate\n- **Max Account Leverage**: User's current maximum account leverage setting\n- **Base IMR_i**: Single symbol base initial margin rate\n- **IMR Factor_i**: Single symbol IMR calculation factor, from v1/client/info\n- **Position Notional_i**: Single symbol position notional sum\n- **position_qty_i**: Single symbol position quantity\n- **entry_price_i**: Single symbol entry price (avg. open price)\n\n## Example\n\n**Position unrealized ROI** = Position unrealized PNL / (IMR_i * abs(position_qty_i * entry_price_i)) * 100% = 216.69 / (0.1 * abs(-3 * 1710.64)) * 100% = 42.22%\n\n**ETH IMR_i** = Max(1/10, 0.1, 0.0000003754 * abs(-4915.23)^(4/5)) = Max(0.1, 0.1, 0.000337077174) = 0.1\n\n- Max Account Leverage = 10\n- ETH Base IMR_i = 0.1\n- ETH IMR Factor_i = 0.0000003754\n- ETH position_qty_i = -3\n- ETH entry_price_i = 1710.64\n- ETH mark_price_i = 1638.41\n- ETH Position Notional = -3 * 1638.41 = -4915.23\n- ETH Position unrealized PNL = 216.69",
    "formula": "Position unrealized ROI = Position unrealized PNL / ( IMR_i *  abs(position_qty_i * entry_price_i) ) * 100%, IMR_i = Max(1 / Max Account Leverage, Base IMR i, IMR Factor i * Abs(Position Notional i)^(4/5))",
    "inputs": [
      {
        "key": "inputs",
        "type": "object",
        "factorType": {
          "baseType": "object",
          "constraints": {},
          "nullable": false,
          "array": false,
          "properties": [
            {
              "key": "positionQty",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              }
            },
            {
              "key": "openPrice",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              }
            },
            {
              "key": "IMR",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              }
            },
            {
              "key": "unrealizedPnL",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              }
            }
          ]
        }
      }
    ],
    "outputs": [
      {
        "key": "result",
        "type": "number",
        "factorType": {
          "baseType": "number",
          "nullable": false,
          "array": false
        },
        "description": "The ROI of the position's unrealized profit or loss."
      }
    ],
    "formulaText": "{\n  const { openPrice, IMR } = inputs;\n\n  if (\n    inputs.unrealizedPnL === 0 ||\n    inputs.positionQty === 0 ||\n    openPrice === 0 ||\n    IMR === 0\n  )\n    return 0;\n\n  return new Decimal(inputs.unrealizedPnL)\n    .div(new Decimal(Math.abs(inputs.positionQty)).mul(openPrice).mul(IMR))\n    .toNumber();\n}",
    "sourceCode": "export function unrealizedPnLROI(inputs: UnrealPnLROIInputs): number {\n  const { openPrice, IMR } = inputs;\n\n  if (\n    inputs.unrealizedPnL === 0 ||\n    inputs.positionQty === 0 ||\n    openPrice === 0 ||\n    IMR === 0\n  )\n    return 0;\n\n  return new Decimal(inputs.unrealizedPnL)\n    .div(new Decimal(Math.abs(inputs.positionQty)).mul(openPrice).mul(IMR))\n    .toNumber();\n}",
    "localNpmInfo": {
      "packageName": "@orderly.network/perp",
      "functionName": "unrealizedPnLROI",
      "enabled": true
    }
  },
  {
    "id": "totalUnrealizedPnl",
    "name": "Total Unrealized PNL",
    "version": "1.0.0",
    "description": "## Term Definitions\n\n- **Total Unrealized PNL**: Sum of all current unrealized profit and loss for user's positions\n- **unrealized_pnl_i**: Current unrealized profit and loss for a single symbol\n- **position_qty_i**: Single symbol position quantity\n- **mark_price_i**: Single symbol mark price\n- **entry_price_i**: Single symbol entry price (avg. open price)\n\n## Example\n\n**BTC-PERP unrealized_pnl_i** = 0.2 * (25986.2 - 26067) = -16.16\n\n**ETH-PERP unrealized_pnl_i** = -3 * (1638.41 - 1710.64) = 216.69\n\nfor example \n\nBTC-PERP unrealized_pnl_i = 0.2 * (25986.2 - 26067) = -16.16\n\nETH-PERP unrealized_pnl_i = -3 * (1638.41 - 1710.64) = 216.69\n\nTotal Unrealized PNL = -16.16 + 216.69 = 200.53",
    "formula": "Total Unrealized PNL = sum ( unrealized_pnl_i ), unrealized_pnl_i = position_qty_i * ( mark_price_i - entry_price _i )",
    "inputs": [
      {
        "key": "positions",
        "type": "object",
        "factorType": {
          "baseType": "object",
          "constraints": {},
          "nullable": false,
          "array": true,
          "properties": [
            {
              "key": "account_id",
              "type": "string",
              "factorType": {
                "baseType": "string",
                "nullable": true,
                "array": false
              }
            },
            {
              "key": "symbol",
              "type": "string",
              "factorType": {
                "baseType": "string",
                "nullable": false,
                "array": false
              }
            },
            {
              "key": "position_qty",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              }
            },
            {
              "key": "cost_position",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              }
            },
            {
              "key": "last_sum_unitary_funding",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              }
            },
            {
              "key": "pending_long_qty",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              }
            },
            {
              "key": "pending_short_qty",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              }
            },
            {
              "key": "settle_price",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              }
            },
            {
              "key": "average_open_price",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              }
            },
            {
              "key": "unrealized_pnl",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              }
            },
            {
              "key": "unrealized_pnl_index",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": true,
                "array": false
              }
            },
            {
              "key": "unrealized_pnl_ROI",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              }
            },
            {
              "key": "unsettled_pnl",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              }
            },
            {
              "key": "unsettled_pnl_ROI",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              }
            },
            {
              "key": "unrealized_pnl_ROI_index",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": true,
                "array": false
              }
            },
            {
              "key": "mark_price",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              }
            },
            {
              "key": "index_price",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": true,
                "array": false
              }
            },
            {
              "key": "est_liq_price",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": true,
                "array": false
              }
            },
            {
              "key": "timestamp",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              }
            },
            {
              "key": "mmr",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              },
              "description": "\nMaintenance margin ratio"
            },
            {
              "key": "imr",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              }
            },
            {
              "key": "IMR_withdraw_orders",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              }
            },
            {
              "key": "MMR_with_orders",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              }
            },
            {
              "key": "pnl_24_h",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              }
            },
            {
              "key": "fee_24_h",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              }
            },
            {
              "key": "fundingFee",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": true,
                "array": false
              }
            },
            {
              "key": "leverage",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              }
            }
          ]
        }
      }
    ],
    "outputs": [
      {
        "key": "result",
        "type": "number",
        "factorType": {
          "baseType": "number",
          "nullable": false,
          "array": false
        },
        "description": "The total unrealized profit or loss of all positions."
      }
    ],
    "formulaText": "{\n  return positions.reduce((acc, cur) => {\n    return (\n      acc +\n      unrealizedPnL({\n        qty: cur.position_qty,\n        openPrice: cur.average_open_price,\n        markPrice: cur.mark_price,\n      })\n    );\n  }, 0);\n}",
    "sourceCode": "export function totalUnrealizedPnL(positions: API.Position[]): number {\n  return positions.reduce((acc, cur) => {\n    return (\n      acc +\n      unrealizedPnL({\n        qty: cur.position_qty,\n        openPrice: cur.average_open_price,\n        markPrice: cur.mark_price,\n      })\n    );\n  }, 0);\n}",
    "localNpmInfo": {
      "packageName": "@orderly.network/perp",
      "functionName": "totalUnrealizedPnL",
      "enabled": true
    }
  },
  {
    "id": "liqPrice",
    "name": "Position Liquidation Price",
    "version": "1.0.0",
    "description": "## Term Definitions\n\n- **Position Liq. Price**: Single symbol position liquidation price\n- **total_collateral_value**: Total asset value of user account margin (USDC denominated)\n- **total_notional**: Sum of current position notional values\n- **position_qty_i**: Single symbol position quantity\n- **mark_price_i**: Single symbol mark price\n- **MMR_i**: Single symbol maintenance margin rate\n- **Base MMR_i**: Single symbol base maintenance margin rate\n- **Base IMR_i**: Single symbol base initial margin rate\n- **IMR Factor_i**: Single symbol IMR calculation factor, from v1/client/info\n- **Position Notional_i**: Single symbol position notional sum\n\n## MMR Formula\n\nMMR_i = Max(Base MMR_i, (Base MMR_i / Base IMR_i) * IMR Factor_i * Abs(Position Notional_i)^(4/5))\n\n## Example - BTC Position\n\n**BTC Position Liq. Price** = max(25986.2 + (1981.66 - 505.6215) / (abs(0.2) * 0.05 - 0.2), 0) = 18217.57\n\n- total_collateral_value = 1981.66\n- sum(abs(position_qty_i) * mark_price_i * MMR_i) = 505.6215\n- BTC: abs(position_qty_i) * mark_price_i * MMR_i = 5197.2 * 0.05\n- ETH: abs(position_qty_i) * mark_price_i * MMR_i = 4915.23 * 0.05\n- BTC MMR_i = Max(0.05, (0.05 / 0.1) * 0.0000002512 * 5197.2^(4/5)) = Max(0.05, 0.000117924809) = 0.05\n- position_qty_i = 0.2\n- mark_price_i = 25986.2\n\n## Example - ETH Position\n\n**ETH Position Liq. Price** = max(1638.41 + (1981.66 - 505.6215) / (abs(-3) * 0.05 + 3), 0) = 2106.99365\n\n- ETH MMR_i = Max(0.05, (0.05 / 0.1) * 0.0000003754 * 4915.23^(4/5)) = Max(0.05, 0.000168538587) = 0.05\n- position_qty_i = -3\n- mark_price_i = 1638.41",
    "formula": "Position Liq. Price = max(mark_price_i + (total_collateral_value - sum(abs(position_qty_i) * mark_price_i * MMR_i)) / (abs(position_qty_i) * MMR_i - position_qty_i), 0)",
    "inputs": [
      {
        "key": "inputs",
        "type": "object",
        "factorType": {
          "baseType": "object",
          "constraints": {},
          "nullable": false,
          "array": false,
          "properties": [
            {
              "key": "markPrice",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              }
            },
            {
              "key": "totalCollateral",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              }
            },
            {
              "key": "positionQty",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              }
            },
            {
              "key": "positions",
              "type": "object",
              "factorType": {
                "baseType": "object",
                "nullable": false,
                "array": true,
                "properties": [
                  {
                    "key": "position_qty",
                    "type": "number",
                    "factorType": {
                      "baseType": "number",
                      "nullable": false,
                      "array": false
                    }
                  },
                  {
                    "key": "mark_price",
                    "type": "number",
                    "factorType": {
                      "baseType": "number",
                      "nullable": false,
                      "array": false
                    }
                  },
                  {
                    "key": "mmr",
                    "type": "number",
                    "factorType": {
                      "baseType": "number",
                      "nullable": false,
                      "array": false
                    },
                    "description": "\nMaintenance margin ratio"
                  }
                ]
              }
            },
            {
              "key": "MMR",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              }
            }
          ]
        }
      }
    ],
    "outputs": [
      {
        "key": "result",
        "type": "number",
        "factorType": {
          "baseType": "number",
          "nullable": true,
          "array": false
        },
        "description": "The liquidation price of the position."
      }
    ],
    "formulaText": "{\n  const { markPrice, totalCollateral, positions, positionQty, MMR } = inputs;\n\n  // console.log(\"inputs\", inputs);\n\n  if (positionQty === 0 || totalCollateral === 0) {\n    return null;\n  }\n\n  // totalNotional of all poisitions\n  const totalNotional = positions.reduce<Decimal>((acc, cur) => {\n    return acc.add(\n      new Decimal(notional(cur.position_qty, cur.mark_price)).mul(cur.mmr),\n    );\n  }, zero);\n\n  return Math.max(\n    new Decimal(markPrice)\n      .add(\n        new Decimal(totalCollateral)\n          .sub(totalNotional)\n          .div(new Decimal(positionQty).abs().mul(MMR).sub(positionQty)),\n      )\n      .toNumber(),\n    0,\n  );\n}",
    "sourceCode": "export function liqPrice(inputs: LiqPriceInputs): number | null {\n  const { markPrice, totalCollateral, positions, positionQty, MMR } = inputs;\n\n  // console.log(\"inputs\", inputs);\n\n  if (positionQty === 0 || totalCollateral === 0) {\n    return null;\n  }\n\n  // totalNotional of all poisitions\n  const totalNotional = positions.reduce<Decimal>((acc, cur) => {\n    return acc.add(\n      new Decimal(notional(cur.position_qty, cur.mark_price)).mul(cur.mmr),\n    );\n  }, zero);\n\n  return Math.max(\n    new Decimal(markPrice)\n      .add(\n        new Decimal(totalCollateral)\n          .sub(totalNotional)\n          .div(new Decimal(positionQty).abs().mul(MMR).sub(positionQty)),\n      )\n      .toNumber(),\n    0,\n  );\n}",
    "localNpmInfo": {
      "packageName": "@orderly.network/perp",
      "functionName": "liqPrice",
      "enabled": true
    }
  },
  {
    "id": "maintenanceMargin",
    "name": "Position maintenance margin",
    "version": "1.0.0",
    "description": "## Term Definitions\n\n- **Position maintenance margin**: Single symbol maintenance margin\n- **MMR_i**: Single symbol maintenance margin rate\n- **Base MMR_i**: Single symbol base maintenance margin rate\n- **Base IMR_i**: Single symbol base initial margin rate\n- **IMR Factor_i**: Single symbol IMR calculation factor, from v1/client/info\n- **Position Notional_i**: Single symbol position notional sum\n- **position_qty_i**: Single symbol position quantity\n- **mark_price_i**: Single symbol mark price\n\n## MMR Formula\n\nMMR_i = Max(Base MMR_i, (Base MMR_i / Base IMR_i) * IMR Factor_i * Abs(Position Notional_i)^(4/5))\n\n## Example\n\n**BTC Position maintenance margin** = abs(position_qty_i * mark_price_i * MMR_i) = abs(0.2 * 25986.2 * 0.05) = 259.86\n\n**BTC MMR_i** = Max(0.05, (0.05 / 0.1) * 0.0000002512 * 5197.2^(4/5)) = Max(0.05, 0.000117924809) = 0.05\n\n- BTC Base MMR_i = 0.05\n- BTC Base IMR_i = 0.1\n- BTC IMR Factor_i = 0.0000002512\n- Abs(BTC Position Notional_i) = 5197.2\n- position_qty_i = 0.2\n- mark_price_i = 25986.2",
    "formula": "Position maintenance margin = abs (position_qty_i  * mark_price_i * MMR_i )",
    "inputs": [
      {
        "key": "inputs",
        "type": "object",
        "factorType": {
          "baseType": "object",
          "constraints": {},
          "nullable": false,
          "array": false,
          "properties": [
            {
              "key": "positionQty",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              }
            },
            {
              "key": "markPrice",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              }
            },
            {
              "key": "MMR",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              }
            }
          ]
        }
      }
    ],
    "outputs": [
      {
        "key": "result",
        "type": "number",
        "factorType": {
          "baseType": "number"
        },
        "description": "The maintenance margin of the position."
      }
    ],
    "formulaText": "{\n  const { positionQty, markPrice, MMR } = inputs;\n\n  return new Decimal(positionQty).mul(markPrice).mul(MMR).abs().toNumber();\n}",
    "sourceCode": "export function maintenanceMargin(inputs: MMInputs) {\n  const { positionQty, markPrice, MMR } = inputs;\n\n  return new Decimal(positionQty).mul(markPrice).mul(MMR).abs().toNumber();\n}",
    "localNpmInfo": {
      "packageName": "@orderly.network/perp",
      "functionName": "maintenanceMargin",
      "enabled": true
    }
  },
  {
    "id": "unsettlementPnl",
    "name": "Position Unrealized PNL",
    "version": "1.0.0",
    "description": "## Term Definitions\n\n- **Position Unrealized PNL**: Single symbol unrealized profit and loss\n- **position_qty_i**: Single symbol position quantity\n- **mark_price_i**: Single symbol mark price\n- **entry_price_i**: Single symbol entry price (avg. open price)\n\n## Example\n\n**ETH Position Unrealized PNL** = position_qty_i * (mark_price_i - entry_price_i) = -3 * (1638.41 - 1710.64) = 216.69\n\n- ETH position_qty_i = -3\n- ETH mark_price_i = 1638.41\n- ETH entry_price_i = 1710.64",
    "formula": "Position Unrealized PNL = position_qty_i * (mark_price_i - entry_price_i)",
    "inputs": [
      {
        "key": "inputs",
        "type": "object",
        "factorType": {
          "baseType": "object",
          "constraints": {},
          "nullable": false,
          "array": false,
          "properties": [
            {
              "key": "positionQty",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              }
            },
            {
              "key": "markPrice",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              }
            },
            {
              "key": "costPosition",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              }
            },
            {
              "key": "sumUnitaryFunding",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              }
            },
            {
              "key": "lastSumUnitaryFunding",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              }
            }
          ]
        }
      }
    ],
    "outputs": [
      {
        "key": "result",
        "type": "number",
        "factorType": {
          "baseType": "number",
          "nullable": false,
          "array": false
        },
        "description": "The unrealized profit or loss of each position."
      }
    ],
    "formulaText": "{\n  const {\n    positionQty,\n    markPrice,\n    costPosition,\n    sumUnitaryFunding,\n    lastSumUnitaryFunding,\n  } = inputs;\n\n  const qty = new Decimal(positionQty);\n\n  return qty\n    .mul(markPrice)\n    .sub(costPosition)\n    .sub(qty.mul(new Decimal(sumUnitaryFunding).sub(lastSumUnitaryFunding)))\n    .toNumber();\n}",
    "sourceCode": "export function unsettlementPnL(inputs: UnsettlementPnLInputs): number {\n  const {\n    positionQty,\n    markPrice,\n    costPosition,\n    sumUnitaryFunding,\n    lastSumUnitaryFunding,\n  } = inputs;\n\n  const qty = new Decimal(positionQty);\n\n  return qty\n    .mul(markPrice)\n    .sub(costPosition)\n    .sub(qty.mul(new Decimal(sumUnitaryFunding).sub(lastSumUnitaryFunding)))\n    .toNumber();\n}",
    "localNpmInfo": {
      "packageName": "@orderly.network/perp",
      "functionName": "unsettlementPnL",
      "enabled": true
    }
  },
  {
    "id": "totalUnsettlementPnL",
    "name": "Total Unsettlement PNL",
    "version": "1.0.0",
    "description": "## Term Definitions\n\n- **total unsettlement PNL**: Sum of user account's unsettled PNL\n- **mark_price_i**: Single symbol mark price\n- **position_qty_i**: Single symbol position quantity\n- **cost_position_i**: Single symbol notional snapshot from last settlement, `/v1/position`\n- **sum_unitary_funding_i**: Single symbol current cumulative unit funding fee, `/v1/public/funding_rate`\n- **last_sum_unitary_funding_i**: Single symbol cumulative unit funding fee from last settlement, `/v1/position`\n\n## Example\n\n**BTC-PERP Unsettlement PNL** = 0.2 * 25986.2 - 5197.2 - 0.2 * (-1585.92 + 1583.92) = 0.44\n\n**ETH-PERP Unsettlement PNL** = -3 * 1638.41 + 4902.45 + 3 * (-52.728 + 50.728) = -18.78\n\n**Total Unsettlement PNL** = 0.44 - 18.78 = -18.34",
    "formula": "Unsettlement PNL = position_qty_i * mark_price_i - cost_position_i - position_qty_i * (sum_unitary_funding_i - last_sum_unitary_funding_i)",
    "inputs": [
      {
        "key": "positions",
        "type": "object",
        "factorType": {
          "baseType": "object",
          "constraints": {},
          "nullable": false,
          "array": true,
          "properties": [
            {
              "key": "account_id",
              "type": "string",
              "factorType": {
                "baseType": "string",
                "nullable": true,
                "array": false
              }
            },
            {
              "key": "symbol",
              "type": "string",
              "factorType": {
                "baseType": "string",
                "nullable": false,
                "array": false
              }
            },
            {
              "key": "position_qty",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              }
            },
            {
              "key": "cost_position",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              }
            },
            {
              "key": "last_sum_unitary_funding",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              }
            },
            {
              "key": "pending_long_qty",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              }
            },
            {
              "key": "pending_short_qty",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              }
            },
            {
              "key": "settle_price",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              }
            },
            {
              "key": "average_open_price",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              }
            },
            {
              "key": "unrealized_pnl",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              }
            },
            {
              "key": "unrealized_pnl_index",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": true,
                "array": false
              }
            },
            {
              "key": "unrealized_pnl_ROI",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              }
            },
            {
              "key": "unsettled_pnl",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              }
            },
            {
              "key": "unsettled_pnl_ROI",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              }
            },
            {
              "key": "unrealized_pnl_ROI_index",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": true,
                "array": false
              }
            },
            {
              "key": "mark_price",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              }
            },
            {
              "key": "index_price",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": true,
                "array": false
              }
            },
            {
              "key": "est_liq_price",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": true,
                "array": false
              }
            },
            {
              "key": "timestamp",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              }
            },
            {
              "key": "mmr",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              },
              "description": "\nMaintenance margin ratio"
            },
            {
              "key": "imr",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              }
            },
            {
              "key": "IMR_withdraw_orders",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              }
            },
            {
              "key": "MMR_with_orders",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              }
            },
            {
              "key": "pnl_24_h",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              }
            },
            {
              "key": "fee_24_h",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              }
            },
            {
              "key": "fundingFee",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": true,
                "array": false
              }
            },
            {
              "key": "leverage",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              }
            },
            {
              "key": "sum_unitary_funding",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              }
            }
          ]
        }
      }
    ],
    "outputs": [
      {
        "key": "result",
        "type": "number",
        "factorType": {
          "baseType": "number",
          "nullable": false,
          "array": false
        },
        "description": "The total unrealized profit or loss of all positions."
      }
    ],
    "formulaText": "{\n  if (!Array.isArray(positions) || positions.length === 0) {\n    return 0;\n  }\n\n  return positions.reduce((acc, cur) => {\n    return (\n      acc +\n      unsettlementPnL({\n        positionQty: cur.position_qty,\n        markPrice: cur.mark_price,\n        costPosition: cur.cost_position,\n        sumUnitaryFunding: cur.sum_unitary_funding,\n        lastSumUnitaryFunding: cur.last_sum_unitary_funding,\n      })\n    );\n  }, 0);\n}",
    "sourceCode": "export function totalUnsettlementPnL(\n  positions: (API.Position & { sum_unitary_funding: number })[],\n): number {\n  if (!Array.isArray(positions) || positions.length === 0) {\n    return 0;\n  }\n\n  return positions.reduce((acc, cur) => {\n    return (\n      acc +\n      unsettlementPnL({\n        positionQty: cur.position_qty,\n        markPrice: cur.mark_price,\n        costPosition: cur.cost_position,\n        sumUnitaryFunding: cur.sum_unitary_funding,\n        lastSumUnitaryFunding: cur.last_sum_unitary_funding,\n      })\n    );\n  }, 0);\n}",
    "localNpmInfo": {
      "packageName": "@orderly.network/perp",
      "functionName": "totalUnsettlementPnL",
      "enabled": true
    }
  },
  {
    "id": "MMR",
    "name": "Position Maintenance Margin Rate",
    "version": "1.0.0",
    "description": "## Term Definitions\n\n- **MMR_i**: Single symbol maintenance margin rate\n- **Base MMR_i**: Single symbol base maintenance margin rate\n- **Base IMR_i**: Single symbol base initial margin rate\n- **IMR Factor_i**: Single symbol IMR calculation factor, from v1/client/info\n- **Position Notional_i**: Single symbol position notional sum\n- **position_qty_i**: Single symbol position quantity\n- **mark_price_i**: Single symbol mark price\n\n## Example\n\n**BTC MMR_i** = Max(0.05, (0.05 / 0.1) * 0.0000002512 * 5197.2^(4/5)) = Max(0.05, 0.000117924809) = 0.05\n\n- BTC Base MMR_i = 0.05\n- BTC Base IMR_i = 0.1\n- BTC IMR Factor_i = 0.0000002512\n- Abs(BTC Position Notional_i) = 5197.2\n- position_qty_i = 0.2\n- mark_price_i = 25986.2",
    "formula": "MMR_i = Max(Base MMR_i, (Base MMR_i / Base IMR_i) * IMR Factor_i * Abs(Position Notional_i)^(4/5))",
    "inputs": [
      {
        "key": "inputs",
        "type": "object",
        "factorType": {
          "baseType": "object",
          "constraints": {},
          "nullable": false,
          "array": false,
          "properties": [
            {
              "key": "baseMMR",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              }
            },
            {
              "key": "baseIMR",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              }
            },
            {
              "key": "IMRFactor",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              }
            },
            {
              "key": "positionNotional",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              }
            },
            {
              "key": "IMR_factor_power",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              }
            }
          ]
        }
      }
    ],
    "outputs": [
      {
        "key": "result",
        "type": "number",
        "factorType": {
          "baseType": "number",
          "nullable": false,
          "array": false
        },
        "description": "The MMR of the position."
      }
    ],
    "formulaText": "{\n  const {\n    baseMMR,\n    baseIMR,\n    IMRFactor,\n    positionNotional,\n    IMR_factor_power = IMRFactorPower,\n  } = inputs;\n  return Math.max(\n    baseMMR,\n    new Decimal(baseMMR)\n      .div(baseIMR)\n      .mul(IMRFactor)\n      .mul(Math.pow(Math.abs(positionNotional), IMR_factor_power))\n      // .toPower(IMR_factor_power)\n      .toNumber(),\n  );\n}",
    "sourceCode": "export function MMR(inputs: MMRInputs): number {\n  const {\n    baseMMR,\n    baseIMR,\n    IMRFactor,\n    positionNotional,\n    IMR_factor_power = IMRFactorPower,\n  } = inputs;\n  return Math.max(\n    baseMMR,\n    new Decimal(baseMMR)\n      .div(baseIMR)\n      .mul(IMRFactor)\n      .mul(Math.pow(Math.abs(positionNotional), IMR_factor_power))\n      // .toPower(IMR_factor_power)\n      .toNumber(),\n  );\n}",
    "localNpmInfo": {
      "packageName": "@orderly.network/perp",
      "functionName": "MMR",
      "enabled": true
    }
  },
  {
    "id": "maxPositionNotional",
    "name": "maxPositionNotional",
    "version": "1.0.0",
    "description": "calculate the max position notional",
    "formula": "max_notional = ( (1/ (leverage * imr_factor) ) ^ (1/0.8)",
    "inputs": [
      {
        "key": "inputs",
        "type": "object",
        "factorType": {
          "baseType": "object",
          "constraints": {},
          "nullable": false,
          "array": false,
          "properties": [
            {
              "key": "leverage",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              },
              "description": "symbol leverage"
            },
            {
              "key": "IMRFactor",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              }
            }
          ]
        }
      }
    ],
    "outputs": [
      {
        "key": "result",
        "type": "number",
        "factorType": {
          "baseType": "number"
        }
      }
    ],
    "formulaText": "{\n  const { leverage, IMRFactor } = inputs;\n  return new Decimal(1)\n    .div(new Decimal(leverage).mul(IMRFactor))\n    .pow(1 / 0.8)\n    .toNumber();\n}",
    "sourceCode": "export function maxPositionNotional(inputs: {\n  /** symbol leverage */\n  leverage: number;\n  IMRFactor: number;\n}) {\n  const { leverage, IMRFactor } = inputs;\n  return new Decimal(1)\n    .div(new Decimal(leverage).mul(IMRFactor))\n    .pow(1 / 0.8)\n    .toNumber();\n}",
    "localNpmInfo": {
      "packageName": "@orderly.network/perp",
      "functionName": "maxPositionNotional",
      "enabled": true
    }
  }
]