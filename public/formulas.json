[
  {
    "id": "imr",
    "name": "IMR",
    "version": "1.0.0",
    "description": "Initial margin rate for a symbol.\nMax(1 / Max Account Leverage, Base IMR i, IMR Factor i * Abs(Position Notional i + Order Notional i)^(4/5))",
    "inputs": [
      {
        "key": "inputs",
        "type": "object",
        "factorType": {
          "baseType": "object",
          "constraints": {},
          "nullable": false,
          "array": false,
          "properties": [
            {
              "key": "maxLeverage",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              },
              "description": "\neffective max leverage"
            },
            {
              "key": "baseIMR",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              }
            },
            {
              "key": "IMR_Factor",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              }
            },
            {
              "key": "positionNotional",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              }
            },
            {
              "key": "ordersNotional",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              }
            },
            {
              "key": "IMR_factor_power",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": true,
                "array": false
              }
            }
          ]
        }
      }
    ],
    "outputs": [
      {
        "key": "result",
        "type": "number",
        "factorType": {
          "baseType": "number",
          "nullable": false,
          "array": false
        }
      }
    ],
    "formulaText": "{\n  const {\n    maxLeverage,\n    baseIMR,\n    IMR_Factor,\n    positionNotional,\n    ordersNotional: orderNotional,\n    IMR_factor_power = IMRFactorPower,\n  } = inputs;\n  return Math.max(\n    1 / maxLeverage,\n    baseIMR,\n    new Decimal(IMR_Factor)\n      .mul(\n        new Decimal(positionNotional)\n          .add(orderNotional)\n          .abs()\n          .toPower(IMR_factor_power),\n      )\n      .toNumber(),\n  );\n}",
    "sourceCode": "export function IMR(inputs: IMRInputs): number {\n  const {\n    maxLeverage,\n    baseIMR,\n    IMR_Factor,\n    positionNotional,\n    ordersNotional: orderNotional,\n    IMR_factor_power = IMRFactorPower,\n  } = inputs;\n  return Math.max(\n    1 / maxLeverage,\n    baseIMR,\n    new Decimal(IMR_Factor)\n      .mul(\n        new Decimal(positionNotional)\n          .add(orderNotional)\n          .abs()\n          .toPower(IMR_factor_power),\n      )\n      .toNumber(),\n  );\n}",
    "localNpmInfo": {
      "packageName": "@orderly.network/perp",
      "functionName": "IMR",
      "enabled": true
    }
  },
  {
    "id": "maxQty",
    "name": "maxQty",
    "version": "1.0.0",
    "description": "Maximum order quantity.",
    "inputs": [
      {
        "key": "side",
        "type": "number",
        "factorType": {
          "baseType": "number",
          "constraints": {},
          "nullable": false,
          "array": false
        }
      },
      {
        "key": "inputs",
        "type": "object",
        "factorType": {
          "baseType": "object",
          "constraints": {},
          "nullable": false,
          "array": false,
          "properties": [
            {
              "key": "symbol",
              "type": "string",
              "factorType": {
                "baseType": "string",
                "nullable": false,
                "array": false
              }
            },
            {
              "key": "baseMaxQty",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              }
            },
            {
              "key": "totalCollateral",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              },
              "description": "\nTotal collateral of the user (denominated in USDC), can be calculated from totalCollateral."
            },
            {
              "key": "maxLeverage",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              }
            },
            {
              "key": "baseIMR",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              }
            },
            {
              "key": "otherIMs",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              }
            },
            {
              "key": "markPrice",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              }
            },
            {
              "key": "positionQty",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              }
            },
            {
              "key": "buyOrdersQty",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              }
            },
            {
              "key": "sellOrdersQty",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              }
            },
            {
              "key": "IMR_Factor",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              }
            },
            {
              "key": "takerFeeRate",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              }
            }
          ]
        }
      },
      {
        "key": "options",
        "type": "object",
        "factorType": {
          "baseType": "object",
          "constraints": {},
          "nullable": true,
          "array": false
        }
      }
    ],
    "outputs": [
      {
        "key": "result",
        "type": "number",
        "factorType": {
          "baseType": "number",
          "nullable": false,
          "array": false
        }
      }
    ],
    "formulaText": "{\n  if (side === OrderSide.BUY) {\n    return maxQtyByLong(inputs);\n  }\n  return maxQtyByShort(inputs);\n}",
    "sourceCode": "export function maxQty(\n  side: OrderSide,\n  inputs: MaxQtyInputs,\n  options?: ResultOptions,\n): number {\n  if (side === OrderSide.BUY) {\n    return maxQtyByLong(inputs);\n  }\n  return maxQtyByShort(inputs);\n}",
    "localNpmInfo": {
      "packageName": "@orderly.network/perp",
      "functionName": "maxQty",
      "enabled": true
    }
  },
  {
    "id": "estLiqPrice",
    "name": "estLiqPrice",
    "version": "1.0.0",
    "description": "Estimated liquidation price",
    "inputs": [
      {
        "key": "inputs",
        "type": "object",
        "factorType": {
          "baseType": "object",
          "constraints": {},
          "nullable": false,
          "array": false,
          "properties": [
            {
              "key": "totalCollateral",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              }
            },
            {
              "key": "markPrice",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              }
            },
            {
              "key": "baseMMR",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              }
            },
            {
              "key": "baseIMR",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              }
            },
            {
              "key": "IMR_Factor",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              }
            },
            {
              "key": "orderFee",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              }
            },
            {
              "key": "positions",
              "type": "object",
              "factorType": {
                "baseType": "object",
                "nullable": false,
                "array": true,
                "properties": [
                  {
                    "key": "position_qty",
                    "type": "number",
                    "factorType": {
                      "baseType": "number",
                      "nullable": false,
                      "array": false
                    }
                  },
                  {
                    "key": "mark_price",
                    "type": "number",
                    "factorType": {
                      "baseType": "number",
                      "nullable": false,
                      "array": false
                    }
                  },
                  {
                    "key": "symbol",
                    "type": "string",
                    "factorType": {
                      "baseType": "string",
                      "nullable": false,
                      "array": false
                    }
                  },
                  {
                    "key": "mmr",
                    "type": "number",
                    "factorType": {
                      "baseType": "number",
                      "nullable": false,
                      "array": false
                    }
                  }
                ]
              }
            },
            {
              "key": "newOrder",
              "type": "object",
              "factorType": {
                "baseType": "object",
                "nullable": false,
                "array": false,
                "properties": [
                  {
                    "key": "symbol",
                    "type": "string",
                    "factorType": {
                      "baseType": "string",
                      "nullable": false,
                      "array": false
                    }
                  },
                  {
                    "key": "qty",
                    "type": "number",
                    "factorType": {
                      "baseType": "number",
                      "nullable": false,
                      "array": false
                    }
                  },
                  {
                    "key": "price",
                    "type": "number",
                    "factorType": {
                      "baseType": "number",
                      "nullable": false,
                      "array": false
                    }
                  }
                ]
              }
            }
          ]
        }
      }
    ],
    "outputs": [
      {
        "key": "result",
        "type": "number",
        "factorType": {
          "baseType": "number",
          "nullable": false,
          "array": false
        }
      }
    ],
    "formulaText": "{\n  const {\n    positions,\n    newOrder,\n    totalCollateral,\n    markPrice,\n    baseIMR,\n    baseMMR,\n    orderFee,\n    IMR_Factor,\n  } = inputs;\n  // opened positions for the symbol\n  let currentPosition:\n    | Pick<\n        orderUtils.PositionExt,\n        \"position_qty\" | \"mark_price\" | \"symbol\" | \"mmr\"\n      >\n    | undefined = undefined;\n\n  let newTotalMM = zero;\n\n  const hasPosition =\n    positions.filter((item) => item.position_qty > 0).length > 0;\n\n  const basePrice = hasPosition ? markPrice : newOrder.price;\n\n  const newOrderNotional = new Decimal(newOrder.qty).mul(newOrder.price);\n\n  for (let index = 0; index < positions.length; index++) {\n    const position = positions[index];\n    let notional = new Decimal(position.position_qty).mul(position.mark_price);\n    if (newOrder.symbol === position.symbol) {\n      currentPosition = position;\n      notional = notional.add(newOrderNotional);\n    }\n\n    newTotalMM = newTotalMM.add(notional.abs().mul(position.mmr));\n  }\n\n  // if no position\n  if (!currentPosition) {\n    newTotalMM = newTotalMM.add(newOrderNotional.mul(baseMMR));\n  }\n\n  const newMMR = Math.max(\n    baseMMR,\n    new Decimal(baseMMR)\n      .div(baseIMR)\n      .mul(IMR_Factor)\n      .mul(\n        newOrderNotional\n          .add(\n            !!currentPosition\n              ? new Decimal(currentPosition.position_qty).mul(\n                  currentPosition.mark_price,\n                )\n              : zero,\n          )\n          .abs(),\n      )\n      .toPower(4 / 5)\n      .toNumber(),\n  );\n\n  // console.log(\"new MMR\", newMMR, newTotalMM.toNumber());\n\n  const newQty = new Decimal(newOrder.qty).add(\n    currentPosition?.position_qty ?? 0,\n  );\n\n  if (newQty.eq(0)) {\n    return 0;\n  }\n\n  const denominator = newQty.abs().mul(newMMR).sub(newQty);\n\n  if (denominator.eq(zero)) {\n    return 0;\n  }\n\n  const price = new Decimal(basePrice)\n    .add(\n      new Decimal(totalCollateral)\n        .sub(newTotalMM)\n        .sub(orderFee)\n        .div(denominator),\n    )\n    .toNumber();\n\n  return Math.max(0, price);\n}",
    "sourceCode": "export function estLiqPrice(inputs: EstimatedLiquidationPriceInputs): number {\n  const {\n    positions,\n    newOrder,\n    totalCollateral,\n    markPrice,\n    baseIMR,\n    baseMMR,\n    orderFee,\n    IMR_Factor,\n  } = inputs;\n  // opened positions for the symbol\n  let currentPosition:\n    | Pick<\n        orderUtils.PositionExt,\n        \"position_qty\" | \"mark_price\" | \"symbol\" | \"mmr\"\n      >\n    | undefined = undefined;\n\n  let newTotalMM = zero;\n\n  const hasPosition =\n    positions.filter((item) => item.position_qty > 0).length > 0;\n\n  const basePrice = hasPosition ? markPrice : newOrder.price;\n\n  const newOrderNotional = new Decimal(newOrder.qty).mul(newOrder.price);\n\n  for (let index = 0; index < positions.length; index++) {\n    const position = positions[index];\n    let notional = new Decimal(position.position_qty).mul(position.mark_price);\n    if (newOrder.symbol === position.symbol) {\n      currentPosition = position;\n      notional = notional.add(newOrderNotional);\n    }\n\n    newTotalMM = newTotalMM.add(notional.abs().mul(position.mmr));\n  }\n\n  // if no position\n  if (!currentPosition) {\n    newTotalMM = newTotalMM.add(newOrderNotional.mul(baseMMR));\n  }\n\n  const newMMR = Math.max(\n    baseMMR,\n    new Decimal(baseMMR)\n      .div(baseIMR)\n      .mul(IMR_Factor)\n      .mul(\n        newOrderNotional\n          .add(\n            !!currentPosition\n              ? new Decimal(currentPosition.position_qty).mul(\n                  currentPosition.mark_price,\n                )\n              : zero,\n          )\n          .abs(),\n      )\n      .toPower(4 / 5)\n      .toNumber(),\n  );\n\n  // console.log(\"new MMR\", newMMR, newTotalMM.toNumber());\n\n  const newQty = new Decimal(newOrder.qty).add(\n    currentPosition?.position_qty ?? 0,\n  );\n\n  if (newQty.eq(0)) {\n    return 0;\n  }\n\n  const denominator = newQty.abs().mul(newMMR).sub(newQty);\n\n  if (denominator.eq(zero)) {\n    return 0;\n  }\n\n  const price = new Decimal(basePrice)\n    .add(\n      new Decimal(totalCollateral)\n        .sub(newTotalMM)\n        .sub(orderFee)\n        .div(denominator),\n    )\n    .toNumber();\n\n  return Math.max(0, price);\n}",
    "localNpmInfo": {
      "packageName": "@orderly.network/perp",
      "functionName": "estLiqPrice",
      "enabled": true
    }
  },
  {
    "id": "unrealizedPnL",
    "name": "unrealizedPnL",
    "version": "1.0.0",
    "description": "Calculates the unrealized profit or loss of a single position.",
    "formula": "qty * (markPrice - openPrice)",
    "inputs": [
      {
        "key": "inputs",
        "type": "object",
        "factorType": {
          "baseType": "object",
          "constraints": {},
          "nullable": false,
          "array": false,
          "properties": [
            {
              "key": "markPrice",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              },
              "description": "symbol mark price"
            },
            {
              "key": "openPrice",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              },
              "description": "symbol open price"
            },
            {
              "key": "qty",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              },
              "description": "symbol quantity"
            }
          ]
        }
      }
    ],
    "outputs": [
      {
        "key": "result",
        "type": "number",
        "factorType": {
          "baseType": "number",
          "nullable": false,
          "array": false
        },
        "description": "The unrealized profit or loss of the position."
      }
    ],
    "formulaText": "{\n  return new Decimal(inputs.qty)\n    .mul(inputs.markPrice - inputs.openPrice)\n    .toNumber();\n}",
    "sourceCode": "export function unrealizedPnL(inputs: UnrealPnLInputs): number {\n  return new Decimal(inputs.qty)\n    .mul(inputs.markPrice - inputs.openPrice)\n    .toNumber();\n}",
    "localNpmInfo": {
      "packageName": "@orderly.network/perp",
      "functionName": "unrealizedPnL",
      "enabled": true
    }
  }
]