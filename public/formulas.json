[
  {
    "id": "totalValue",
    "name": "Total Value",
    "version": "1.0.0",
    "description": "## Definition\n\n**Total Value** = User's total asset value (denominated in USDC), including assets that cannot be used as collateral\n\n**Total holding** = Sum of all holding quantities in the user's account\n\n**usdc balance.holding** = USDC holding quantity\n\n**non-usdc balance.holding * mark price** = Value of non-USDC asset holdings (denominated in USDC)\n\n**holding**: Asset quantity held by the user, from `/v1/client/holding` or v2 Websocket API | Balance\n\n**mark price**: Current price of the asset, from v2 Websocket API | Balance\n\n**total unsettlement PNL** = Sum of user's account unsettled PNL\n\n## Example\n\n```\ntotal_holding = 2000 + 1000 * 1.001 = 3001\nTotal Value = 3001 - 18.34 = 2982.66\ntotal unsettlement PNL = -18.34\n```",
    "formula": "Total Value = total_holding + total unsettlement PNL, total_holding = usdc balance.holding + SUM(non-usdc balance.holding * mark price)",
    "inputs": [
      {
        "key": "inputs",
        "type": "object",
        "factorType": {
          "baseType": "object",
          "constraints": {},
          "nullable": false,
          "array": false,
          "properties": [
            {
              "key": "totalUnsettlementPnL",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              }
            },
            {
              "key": "USDCHolding",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              }
            },
            {
              "key": "nonUSDCHolding",
              "type": "object",
              "factorType": {
                "baseType": "object",
                "nullable": false,
                "array": true,
                "properties": [
                  {
                    "key": "holding",
                    "type": "number",
                    "factorType": {
                      "baseType": "number",
                      "nullable": false,
                      "array": false
                    }
                  },
                  {
                    "key": "indexPrice",
                    "type": "number",
                    "factorType": {
                      "baseType": "number",
                      "nullable": false,
                      "array": false
                    }
                  }
                ]
              }
            }
          ]
        }
      }
    ],
    "outputs": [
      {
        "key": "result",
        "type": "number",
        "factorType": {
          "baseType": "number",
          "nullable": false,
          "array": false
        }
      }
    ],
    "formulaText": "{\n  const { totalUnsettlementPnL, USDCHolding, nonUSDCHolding } = inputs;\n  const nonUSDCHoldingValue = nonUSDCHolding.reduce((acc, cur) => {\n    return new Decimal(cur.holding).mul(cur.indexPrice).add(acc);\n  }, zero);\n  return nonUSDCHoldingValue.add(USDCHolding).add(totalUnsettlementPnL);\n}",
    "sourceCode": "export function totalValue(inputs: TotalValueInputs): Decimal {\n  const { totalUnsettlementPnL, USDCHolding, nonUSDCHolding } = inputs;\n  const nonUSDCHoldingValue = nonUSDCHolding.reduce((acc, cur) => {\n    return new Decimal(cur.holding).mul(cur.indexPrice).add(acc);\n  }, zero);\n  return nonUSDCHoldingValue.add(USDCHolding).add(totalUnsettlementPnL);\n}",
    "localNpmInfo": {
      "packageName": "@orderly.network/perp",
      "functionName": "totalValue",
      "enabled": true
    }
  },
  {
    "id": "freeCollateral",
    "name": "Free Collateral",
    "version": "1.0.0",
    "description": "## Definition\n\n**Free collateral**: Total value of available margin in the user's account (denominated in USDC)\n\n**Total_collateral_value**: Total value of collateral assets in the user's account (denominated in USDC)\n\n**total_initial_margin_with_orders**: Total initial margin used by the user (including positions and orders)\n\n**initial_margin_i with order**: Initial margin for symbol i (considering both positions and orders)\n\n**IMR_i (with_orders)**: Initial margin rate for a single symbol (considering both position and order notional)\n\n**Max Account Leverage**: Maximum leverage set by the user, from `/v1/client/info.max_leverage`\n\n**Base IMR i**: Base initial margin rate for a single symbol, from `/v1/public/info`\n\n**IMR Factor i**: IMR calculation factor for a single symbol, from `v1/client/info`\n\n**Position Notional i**: Sum of position notional for a single symbol\n\n**Order Notional i**: Sum of order notional for a single symbol\n\n**position_notional_with_orders_i**: Sum of position and order notional for a single symbol\n\n**mark_price_i**: Mark price for a single symbol\n\n**position_qty_with_orders_i**: Sum of position and order quantity for a single symbol\n\n**position_qty_i**: Position quantity for a single symbol\n\n**sum_position_qty_buy_orders_i**: Sum of long order quantity for a single symbol [algo orders should be ignored]\n\n**sum_position_qty_sell_orders_i**: Sum of short order quantity for a single symbol [algo orders should be ignored]\n\n## Example\n\n```\nBTC-PERP position_qty_with_orders_i = max[ abs(0.2+0.3) , abs(0.2-0.5) ] = 0.5\nETH-PERP position_qty_with_orders_i = max[ abs(-3+0), abs(-3+0)] = 3\n\nBTC-PERP position_notional_with_orders_i = 0.5 * 25986.2 = 12993.1\nETH-PERP position_notional_with_orders_i = 3 * 1638.41 = 4915.23\n\nBTC-PERP IMR_i (with_orders) = Max(\n  1 / Max Account Leverage = 1 / 10 = 0.1\n  Base IMR i = 0.1\n  IMR Factor i * Abs(Position Notional i + Order Notional i)^(4/5)) = 0.0000002512 * Abs(5197.2 + 7200 - 14000)^(4/5) = 9.20286609e-5\n) = 0.1\n\nETH-PERP IMR_i (with_orders) = Max(\n  1 / Max Account Leverage = 1 / 10 = 0.1\n  Base IMR i = 0.1\n  IMR Factor i * Abs(Position Notional i + Order Notional i)^(4/5)) = 0.0000003754 * Abs(-4915.23)^(4/5) = 0.00649875988\n) = 0.1\n\ntotal_initial_margin_with_orders = 12993.1 * 0.1 + 4915.23 * 0.1 = 1790.833\nTotal_collateral_value = 1981.66\nFree Collateral = 1981.66 - 1790.833 = 190.82700\n```",
    "formula": "Free Collateral = Total_collateral_value - total_initial_margin_with_orders,Total_collateral_value,\ntotal_initial_margin_with_orders = sum ( position_notional_with_orders_i * IMR_i (with_orders)),\nIMR_i (with_orders) = Max(1 / Max Account Leverage, Base IMR i, IMR Factor i * Abs(Position Notional i + Order Notional i)^(4/5)),\nposition_notional_with_orders_i = abs( mark_price_i * position_qty_with_orders_i),\nposition_qty_with_orders_i = max[ abs(position_qty_i + sum_position_qty_buy_orders_i), abs(position_qty_i - sum_position_qty_sell_orders_i)]",
    "inputs": [
      {
        "key": "inputs",
        "type": "object",
        "factorType": {
          "baseType": "object",
          "constraints": {},
          "nullable": false,
          "array": false,
          "properties": [
            {
              "key": "totalCollateral",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              }
            },
            {
              "key": "totalInitialMarginWithOrders",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              }
            }
          ]
        }
      }
    ],
    "outputs": [
      {
        "key": "result",
        "type": "number",
        "factorType": {
          "baseType": "number",
          "nullable": false,
          "array": false
        }
      }
    ],
    "formulaText": "{\n  const value = inputs.totalCollateral.sub(inputs.totalInitialMarginWithOrders);\n  // free collateral cannot be less than 0\n  return value.isNegative() ? zero : value;\n}",
    "sourceCode": "export function freeCollateral(inputs: FreeCollateralInputs): Decimal {\n  const value = inputs.totalCollateral.sub(inputs.totalInitialMarginWithOrders);\n  // free collateral cannot be less than 0\n  return value.isNegative() ? zero : value;\n}",
    "localNpmInfo": {
      "packageName": "@orderly.network/perp",
      "functionName": "freeCollateral",
      "enabled": true
    }
  },
  {
    "id": "totalCollateral",
    "name": "Total Collateral",
    "version": "1.0.0",
    "description": "## Definition\n\n**discount**: Collateral substitution rate\n\n**Total collateral**: Total value of collateral assets in the user's account (denominated in USDC)\n\n**usdc balance.holding**: USDC holding quantity\n\n**non-usdc balance.holding * mark price**: Value of non-USDC asset holdings (denominated in USDC)\n\n**holding**: Asset quantity held by the user, from `/v1/client/holding` or v2 Websocket API | Balance\n\n**mark price**: Current price of the asset, from v2 Websocket API | Balance\n\n**total unsettlement PNL**: Sum of user's account unsettled PNL\n\n## Example\n\n```\nTotal collateral = 2000 + 1000 * 1.001 * 0 - 18.34 = 1981.66\ntotal unsettlement PNL = -18.34\n```",
    "formula": "Total collateral = usdc balance.holding + SUM(non-usdc balance.holding * mark price * discount) + total unsettlement PNL",
    "inputs": [
      {
        "key": "inputs",
        "type": "object",
        "factorType": {
          "baseType": "object",
          "constraints": {},
          "nullable": false,
          "array": false,
          "properties": [
            {
              "key": "USDCHolding",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              }
            },
            {
              "key": "nonUSDCHolding",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": true
              }
            },
            {
              "key": "unsettlementPnL",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              }
            }
          ]
        }
      }
    ],
    "outputs": [
      {
        "key": "result",
        "type": "number",
        "factorType": {
          "baseType": "number",
          "nullable": false,
          "array": false
        }
      }
    ],
    "formulaText": "{\n  const { USDCHolding, nonUSDCHolding, unsettlementPnL } = inputs;\n  const nonUSDCHoldingValue = nonUSDCHolding.reduce<Decimal>((acc, cur) => {\n    const finalHolding = Math.min(cur.holding, cur.collateralCap);\n    const value = new Decimal(finalHolding)\n      .mul(cur.collateralRatio)\n      .mul(cur.indexPrice);\n    return acc.add(value);\n  }, zero);\n\n  return new Decimal(USDCHolding).add(nonUSDCHoldingValue).add(unsettlementPnL);\n}",
    "sourceCode": "export function totalCollateral(inputs: TotalCollateralValueInputs): Decimal {\n  const { USDCHolding, nonUSDCHolding, unsettlementPnL } = inputs;\n  const nonUSDCHoldingValue = nonUSDCHolding.reduce<Decimal>((acc, cur) => {\n    const finalHolding = Math.min(cur.holding, cur.collateralCap);\n    const value = new Decimal(finalHolding)\n      .mul(cur.collateralRatio)\n      .mul(cur.indexPrice);\n    return acc.add(value);\n  }, zero);\n\n  return new Decimal(USDCHolding).add(nonUSDCHoldingValue).add(unsettlementPnL);\n}",
    "localNpmInfo": {
      "packageName": "@orderly.network/perp",
      "functionName": "totalCollateral",
      "enabled": true
    }
  },
  {
    "id": "imr",
    "name": "IMR",
    "version": "1.0.0",
    "description": "Initial margin rate for a symbol.\nMax(1 / Max Account Leverage, Base IMR i, IMR Factor i * Abs(Position Notional i + Order Notional i)^(4/5))",
    "inputs": [
      {
        "key": "inputs",
        "type": "object",
        "factorType": {
          "baseType": "object",
          "constraints": {},
          "nullable": false,
          "array": false,
          "properties": [
            {
              "key": "maxLeverage",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              },
              "description": "\neffective max leverage"
            },
            {
              "key": "baseIMR",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              }
            },
            {
              "key": "IMR_Factor",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              }
            },
            {
              "key": "positionNotional",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              }
            },
            {
              "key": "ordersNotional",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              }
            },
            {
              "key": "IMR_factor_power",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": true,
                "array": false
              }
            }
          ]
        }
      }
    ],
    "outputs": [
      {
        "key": "result",
        "type": "number",
        "factorType": {
          "baseType": "number",
          "nullable": false,
          "array": false
        }
      }
    ],
    "formulaText": "{\n  const {\n    maxLeverage,\n    baseIMR,\n    IMR_Factor,\n    positionNotional,\n    ordersNotional: orderNotional,\n    IMR_factor_power = IMRFactorPower,\n  } = inputs;\n  return Math.max(\n    1 / maxLeverage,\n    baseIMR,\n    new Decimal(IMR_Factor)\n      .mul(\n        new Decimal(positionNotional)\n          .add(orderNotional)\n          .abs()\n          .toPower(IMR_factor_power),\n      )\n      .toNumber(),\n  );\n}",
    "sourceCode": "export function IMR(inputs: IMRInputs): number {\n  const {\n    maxLeverage,\n    baseIMR,\n    IMR_Factor,\n    positionNotional,\n    ordersNotional: orderNotional,\n    IMR_factor_power = IMRFactorPower,\n  } = inputs;\n  return Math.max(\n    1 / maxLeverage,\n    baseIMR,\n    new Decimal(IMR_Factor)\n      .mul(\n        new Decimal(positionNotional)\n          .add(orderNotional)\n          .abs()\n          .toPower(IMR_factor_power),\n      )\n      .toNumber(),\n  );\n}",
    "localNpmInfo": {
      "packageName": "@orderly.network/perp",
      "functionName": "IMR",
      "enabled": true
    }
  },
  {
    "id": "maxQty",
    "name": "maxQty",
    "version": "1.0.0",
    "description": "Maximum order quantity.",
    "inputs": [
      {
        "key": "side",
        "type": "number",
        "factorType": {
          "baseType": "number",
          "constraints": {},
          "nullable": false,
          "array": false
        }
      },
      {
        "key": "inputs",
        "type": "object",
        "factorType": {
          "baseType": "object",
          "constraints": {},
          "nullable": false,
          "array": false,
          "properties": [
            {
              "key": "symbol",
              "type": "string",
              "factorType": {
                "baseType": "string",
                "nullable": false,
                "array": false
              }
            },
            {
              "key": "baseMaxQty",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              }
            },
            {
              "key": "totalCollateral",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              },
              "description": "\nTotal collateral of the user (denominated in USDC), can be calculated from totalCollateral."
            },
            {
              "key": "maxLeverage",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              }
            },
            {
              "key": "baseIMR",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              }
            },
            {
              "key": "otherIMs",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              }
            },
            {
              "key": "markPrice",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              }
            },
            {
              "key": "positionQty",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              }
            },
            {
              "key": "buyOrdersQty",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              }
            },
            {
              "key": "sellOrdersQty",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              }
            },
            {
              "key": "IMR_Factor",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              }
            },
            {
              "key": "takerFeeRate",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              }
            }
          ]
        }
      },
      {
        "key": "options",
        "type": "object",
        "factorType": {
          "baseType": "object",
          "constraints": {},
          "nullable": true,
          "array": false
        }
      }
    ],
    "outputs": [
      {
        "key": "result",
        "type": "number",
        "factorType": {
          "baseType": "number",
          "nullable": false,
          "array": false
        }
      }
    ],
    "formulaText": "{\n  if (side === OrderSide.BUY) {\n    return maxQtyByLong(inputs);\n  }\n  return maxQtyByShort(inputs);\n}",
    "sourceCode": "export function maxQty(\n  side: OrderSide,\n  inputs: MaxQtyInputs,\n  options?: ResultOptions,\n): number {\n  if (side === OrderSide.BUY) {\n    return maxQtyByLong(inputs);\n  }\n  return maxQtyByShort(inputs);\n}",
    "localNpmInfo": {
      "packageName": "@orderly.network/perp",
      "functionName": "maxQty",
      "enabled": true
    }
  },
  {
    "id": "estLiqPrice",
    "name": "estLiqPrice",
    "version": "1.0.0",
    "description": "Estimated liquidation price",
    "inputs": [
      {
        "key": "inputs",
        "type": "object",
        "factorType": {
          "baseType": "object",
          "constraints": {},
          "nullable": false,
          "array": false,
          "properties": [
            {
              "key": "totalCollateral",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              }
            },
            {
              "key": "markPrice",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              }
            },
            {
              "key": "baseMMR",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              }
            },
            {
              "key": "baseIMR",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              }
            },
            {
              "key": "IMR_Factor",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              }
            },
            {
              "key": "orderFee",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              }
            },
            {
              "key": "positions",
              "type": "object",
              "factorType": {
                "baseType": "object",
                "nullable": false,
                "array": true,
                "properties": [
                  {
                    "key": "position_qty",
                    "type": "number",
                    "factorType": {
                      "baseType": "number",
                      "nullable": false,
                      "array": false
                    }
                  },
                  {
                    "key": "mark_price",
                    "type": "number",
                    "factorType": {
                      "baseType": "number",
                      "nullable": false,
                      "array": false
                    }
                  },
                  {
                    "key": "symbol",
                    "type": "string",
                    "factorType": {
                      "baseType": "string",
                      "nullable": false,
                      "array": false
                    }
                  },
                  {
                    "key": "mmr",
                    "type": "number",
                    "factorType": {
                      "baseType": "number",
                      "nullable": false,
                      "array": false
                    }
                  }
                ]
              }
            },
            {
              "key": "newOrder",
              "type": "object",
              "factorType": {
                "baseType": "object",
                "nullable": false,
                "array": false,
                "properties": [
                  {
                    "key": "symbol",
                    "type": "string",
                    "factorType": {
                      "baseType": "string",
                      "nullable": false,
                      "array": false
                    }
                  },
                  {
                    "key": "qty",
                    "type": "number",
                    "factorType": {
                      "baseType": "number",
                      "nullable": false,
                      "array": false
                    }
                  },
                  {
                    "key": "price",
                    "type": "number",
                    "factorType": {
                      "baseType": "number",
                      "nullable": false,
                      "array": false
                    }
                  }
                ]
              }
            }
          ]
        }
      }
    ],
    "outputs": [
      {
        "key": "result",
        "type": "number",
        "factorType": {
          "baseType": "number",
          "nullable": false,
          "array": false
        }
      }
    ],
    "formulaText": "{\n  const {\n    positions,\n    newOrder,\n    totalCollateral,\n    markPrice,\n    baseIMR,\n    baseMMR,\n    orderFee,\n    IMR_Factor,\n  } = inputs;\n  // opened positions for the symbol\n  let currentPosition:\n    | Pick<\n        orderUtils.PositionExt,\n        \"position_qty\" | \"mark_price\" | \"symbol\" | \"mmr\"\n      >\n    | undefined = undefined;\n\n  let newTotalMM = zero;\n\n  const hasPosition =\n    positions.filter((item) => item.position_qty > 0).length > 0;\n\n  const basePrice = hasPosition ? markPrice : newOrder.price;\n\n  const newOrderNotional = new Decimal(newOrder.qty).mul(newOrder.price);\n\n  for (let index = 0; index < positions.length; index++) {\n    const position = positions[index];\n    let notional = new Decimal(position.position_qty).mul(position.mark_price);\n    if (newOrder.symbol === position.symbol) {\n      currentPosition = position;\n      notional = notional.add(newOrderNotional);\n    }\n\n    newTotalMM = newTotalMM.add(notional.abs().mul(position.mmr));\n  }\n\n  // if no position\n  if (!currentPosition) {\n    newTotalMM = newTotalMM.add(newOrderNotional.mul(baseMMR));\n  }\n\n  const newMMR = Math.max(\n    baseMMR,\n    new Decimal(baseMMR)\n      .div(baseIMR)\n      .mul(IMR_Factor)\n      .mul(\n        newOrderNotional\n          .add(\n            !!currentPosition\n              ? new Decimal(currentPosition.position_qty).mul(\n                  currentPosition.mark_price,\n                )\n              : zero,\n          )\n          .abs(),\n      )\n      .toPower(4 / 5)\n      .toNumber(),\n  );\n\n  // console.log(\"new MMR\", newMMR, newTotalMM.toNumber());\n\n  const newQty = new Decimal(newOrder.qty).add(\n    currentPosition?.position_qty ?? 0,\n  );\n\n  if (newQty.eq(0)) {\n    return 0;\n  }\n\n  const denominator = newQty.abs().mul(newMMR).sub(newQty);\n\n  if (denominator.eq(zero)) {\n    return 0;\n  }\n\n  const price = new Decimal(basePrice)\n    .add(\n      new Decimal(totalCollateral)\n        .sub(newTotalMM)\n        .sub(orderFee)\n        .div(denominator),\n    )\n    .toNumber();\n\n  return Math.max(0, price);\n}",
    "sourceCode": "export function estLiqPrice(inputs: EstimatedLiquidationPriceInputs): number {\n  const {\n    positions,\n    newOrder,\n    totalCollateral,\n    markPrice,\n    baseIMR,\n    baseMMR,\n    orderFee,\n    IMR_Factor,\n  } = inputs;\n  // opened positions for the symbol\n  let currentPosition:\n    | Pick<\n        orderUtils.PositionExt,\n        \"position_qty\" | \"mark_price\" | \"symbol\" | \"mmr\"\n      >\n    | undefined = undefined;\n\n  let newTotalMM = zero;\n\n  const hasPosition =\n    positions.filter((item) => item.position_qty > 0).length > 0;\n\n  const basePrice = hasPosition ? markPrice : newOrder.price;\n\n  const newOrderNotional = new Decimal(newOrder.qty).mul(newOrder.price);\n\n  for (let index = 0; index < positions.length; index++) {\n    const position = positions[index];\n    let notional = new Decimal(position.position_qty).mul(position.mark_price);\n    if (newOrder.symbol === position.symbol) {\n      currentPosition = position;\n      notional = notional.add(newOrderNotional);\n    }\n\n    newTotalMM = newTotalMM.add(notional.abs().mul(position.mmr));\n  }\n\n  // if no position\n  if (!currentPosition) {\n    newTotalMM = newTotalMM.add(newOrderNotional.mul(baseMMR));\n  }\n\n  const newMMR = Math.max(\n    baseMMR,\n    new Decimal(baseMMR)\n      .div(baseIMR)\n      .mul(IMR_Factor)\n      .mul(\n        newOrderNotional\n          .add(\n            !!currentPosition\n              ? new Decimal(currentPosition.position_qty).mul(\n                  currentPosition.mark_price,\n                )\n              : zero,\n          )\n          .abs(),\n      )\n      .toPower(4 / 5)\n      .toNumber(),\n  );\n\n  // console.log(\"new MMR\", newMMR, newTotalMM.toNumber());\n\n  const newQty = new Decimal(newOrder.qty).add(\n    currentPosition?.position_qty ?? 0,\n  );\n\n  if (newQty.eq(0)) {\n    return 0;\n  }\n\n  const denominator = newQty.abs().mul(newMMR).sub(newQty);\n\n  if (denominator.eq(zero)) {\n    return 0;\n  }\n\n  const price = new Decimal(basePrice)\n    .add(\n      new Decimal(totalCollateral)\n        .sub(newTotalMM)\n        .sub(orderFee)\n        .div(denominator),\n    )\n    .toNumber();\n\n  return Math.max(0, price);\n}",
    "localNpmInfo": {
      "packageName": "@orderly.network/perp",
      "functionName": "estLiqPrice",
      "enabled": true
    }
  },
  {
    "id": "unrealizedPnL",
    "name": "unrealizedPnL",
    "version": "1.0.0",
    "description": "Calculates the unrealized profit or loss of a single position.",
    "formula": "qty * (markPrice - openPrice)",
    "inputs": [
      {
        "key": "inputs",
        "type": "object",
        "factorType": {
          "baseType": "object",
          "constraints": {},
          "nullable": false,
          "array": false,
          "properties": [
            {
              "key": "markPrice",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              },
              "description": "symbol mark price"
            },
            {
              "key": "openPrice",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              },
              "description": "symbol open price"
            },
            {
              "key": "qty",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              },
              "description": "symbol quantity"
            }
          ]
        }
      }
    ],
    "outputs": [
      {
        "key": "result",
        "type": "number",
        "factorType": {
          "baseType": "number",
          "nullable": false,
          "array": false
        },
        "description": "The unrealized profit or loss of the position."
      }
    ],
    "formulaText": "{\n  return new Decimal(inputs.qty)\n    .mul(inputs.markPrice - inputs.openPrice)\n    .toNumber();\n}",
    "sourceCode": "export function unrealizedPnL(inputs: UnrealPnLInputs): number {\n  return new Decimal(inputs.qty)\n    .mul(inputs.markPrice - inputs.openPrice)\n    .toNumber();\n}",
    "localNpmInfo": {
      "packageName": "@orderly.network/perp",
      "functionName": "unrealizedPnL",
      "enabled": true
    }
  },
  {
    "id": "unrealizedPnLROI",
    "name": "unrealizedPnLROI",
    "version": "1.0.0",
    "description": "Calculates the return on investment (ROI) of a single position's unrealized profit or loss.",
    "inputs": [
      {
        "key": "inputs",
        "type": "object",
        "factorType": {
          "baseType": "object",
          "constraints": {},
          "nullable": false,
          "array": false,
          "properties": [
            {
              "key": "positionQty",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              }
            },
            {
              "key": "openPrice",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              }
            },
            {
              "key": "IMR",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              }
            },
            {
              "key": "unrealizedPnL",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              }
            }
          ]
        }
      }
    ],
    "outputs": [
      {
        "key": "result",
        "type": "number",
        "factorType": {
          "baseType": "number",
          "nullable": false,
          "array": false
        },
        "description": "The ROI of the position's unrealized profit or loss."
      }
    ],
    "formulaText": "{\n  const { openPrice, IMR } = inputs;\n\n  if (\n    inputs.unrealizedPnL === 0 ||\n    inputs.positionQty === 0 ||\n    openPrice === 0 ||\n    IMR === 0\n  )\n    return 0;\n\n  return new Decimal(inputs.unrealizedPnL)\n    .div(new Decimal(Math.abs(inputs.positionQty)).mul(openPrice).mul(IMR))\n    .toNumber();\n}",
    "sourceCode": "export function unrealizedPnLROI(inputs: UnrealPnLROIInputs): number {\n  const { openPrice, IMR } = inputs;\n\n  if (\n    inputs.unrealizedPnL === 0 ||\n    inputs.positionQty === 0 ||\n    openPrice === 0 ||\n    IMR === 0\n  )\n    return 0;\n\n  return new Decimal(inputs.unrealizedPnL)\n    .div(new Decimal(Math.abs(inputs.positionQty)).mul(openPrice).mul(IMR))\n    .toNumber();\n}",
    "localNpmInfo": {
      "packageName": "@orderly.network/perp",
      "functionName": "unrealizedPnLROI",
      "enabled": true
    }
  },
  {
    "id": "liqPrice",
    "name": "liqPrice",
    "version": "1.0.0",
    "description": "Calculates the liquidation price of a single position.",
    "inputs": [
      {
        "key": "inputs",
        "type": "object",
        "factorType": {
          "baseType": "object",
          "constraints": {},
          "nullable": false,
          "array": false,
          "properties": [
            {
              "key": "markPrice",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              }
            },
            {
              "key": "totalCollateral",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              }
            },
            {
              "key": "positionQty",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              }
            },
            {
              "key": "positions",
              "type": "object",
              "factorType": {
                "baseType": "object",
                "nullable": false,
                "array": true,
                "properties": [
                  {
                    "key": "position_qty",
                    "type": "number",
                    "factorType": {
                      "baseType": "number",
                      "nullable": false,
                      "array": false
                    }
                  },
                  {
                    "key": "mark_price",
                    "type": "number",
                    "factorType": {
                      "baseType": "number",
                      "nullable": false,
                      "array": false
                    }
                  },
                  {
                    "key": "mmr",
                    "type": "number",
                    "factorType": {
                      "baseType": "number",
                      "nullable": false,
                      "array": false
                    },
                    "description": "\nMaintenance margin ratio"
                  }
                ]
              }
            },
            {
              "key": "MMR",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              }
            }
          ]
        }
      }
    ],
    "outputs": [
      {
        "key": "result",
        "type": "number",
        "factorType": {
          "baseType": "number",
          "nullable": true,
          "array": false
        },
        "description": "The liquidation price of the position."
      }
    ],
    "formulaText": "{\n  const { markPrice, totalCollateral, positions, positionQty, MMR } = inputs;\n\n  // console.log(\"inputs\", inputs);\n\n  if (positionQty === 0 || totalCollateral === 0) {\n    return null;\n  }\n\n  // totalNotional of all poisitions\n  const totalNotional = positions.reduce<Decimal>((acc, cur) => {\n    return acc.add(\n      new Decimal(notional(cur.position_qty, cur.mark_price)).mul(cur.mmr),\n    );\n  }, zero);\n\n  return Math.max(\n    new Decimal(markPrice)\n      .add(\n        new Decimal(totalCollateral)\n          .sub(totalNotional)\n          .div(new Decimal(positionQty).abs().mul(MMR).sub(positionQty)),\n      )\n      .toNumber(),\n    0,\n  );\n}",
    "sourceCode": "export function liqPrice(inputs: LiqPriceInputs): number | null {\n  const { markPrice, totalCollateral, positions, positionQty, MMR } = inputs;\n\n  // console.log(\"inputs\", inputs);\n\n  if (positionQty === 0 || totalCollateral === 0) {\n    return null;\n  }\n\n  // totalNotional of all poisitions\n  const totalNotional = positions.reduce<Decimal>((acc, cur) => {\n    return acc.add(\n      new Decimal(notional(cur.position_qty, cur.mark_price)).mul(cur.mmr),\n    );\n  }, zero);\n\n  return Math.max(\n    new Decimal(markPrice)\n      .add(\n        new Decimal(totalCollateral)\n          .sub(totalNotional)\n          .div(new Decimal(positionQty).abs().mul(MMR).sub(positionQty)),\n      )\n      .toNumber(),\n    0,\n  );\n}",
    "localNpmInfo": {
      "packageName": "@orderly.network/perp",
      "functionName": "liqPrice",
      "enabled": true
    }
  },
  {
    "id": "unsettlementPnl",
    "name": "unsettlementPnL",
    "version": "1.0.0",
    "description": "Calculates the unrealized profit or loss of each position.",
    "inputs": [
      {
        "key": "inputs",
        "type": "object",
        "factorType": {
          "baseType": "object",
          "constraints": {},
          "nullable": false,
          "array": false,
          "properties": [
            {
              "key": "positionQty",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              }
            },
            {
              "key": "markPrice",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              }
            },
            {
              "key": "costPosition",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              }
            },
            {
              "key": "sumUnitaryFunding",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              }
            },
            {
              "key": "lastSumUnitaryFunding",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              }
            }
          ]
        }
      }
    ],
    "outputs": [
      {
        "key": "result",
        "type": "number",
        "factorType": {
          "baseType": "number",
          "nullable": false,
          "array": false
        },
        "description": "The unrealized profit or loss of each position."
      }
    ],
    "formulaText": "{\n  const {\n    positionQty,\n    markPrice,\n    costPosition,\n    sumUnitaryFunding,\n    lastSumUnitaryFunding,\n  } = inputs;\n\n  const qty = new Decimal(positionQty);\n\n  return qty\n    .mul(markPrice)\n    .sub(costPosition)\n    .sub(qty.mul(new Decimal(sumUnitaryFunding).sub(lastSumUnitaryFunding)))\n    .toNumber();\n}",
    "sourceCode": "export function unsettlementPnL(inputs: UnsettlementPnLInputs): number {\n  const {\n    positionQty,\n    markPrice,\n    costPosition,\n    sumUnitaryFunding,\n    lastSumUnitaryFunding,\n  } = inputs;\n\n  const qty = new Decimal(positionQty);\n\n  return qty\n    .mul(markPrice)\n    .sub(costPosition)\n    .sub(qty.mul(new Decimal(sumUnitaryFunding).sub(lastSumUnitaryFunding)))\n    .toNumber();\n}",
    "localNpmInfo": {
      "packageName": "@orderly.network/perp",
      "functionName": "unsettlementPnL",
      "enabled": true
    }
  },
  {
    "id": "totalUnsettlementPnL",
    "name": "Total Unsettlement PNL",
    "version": "1.0.0",
    "description": "## Term Definitions\n\n- **total unsettlement PNL**: Sum of user account's unsettled PNL\n- **mark_price_i**: Single symbol mark price\n- **position_qty_i**: Single symbol position quantity\n- **cost_position_i**: Single symbol notional snapshot from last settlement, `/v1/position`\n- **sum_unitary_funding_i**: Single symbol current cumulative unit funding fee, `/v1/public/funding_rate`\n- **last_sum_unitary_funding_i**: Single symbol cumulative unit funding fee from last settlement, `/v1/position`\n\n## Example\n\n**BTC-PERP Unsettlement PNL** = 0.2 * 25986.2 - 5197.2 - 0.2 * (-1585.92 + 1583.92) = 0.44\n\n**ETH-PERP Unsettlement PNL** = -3 * 1638.41 + 4902.45 + 3 * (-52.728 + 50.728) = -18.78\n\n**Total Unsettlement PNL** = 0.44 - 18.78 = -18.34",
    "formula": "Unsettlement PNL = position_qty_i * mark_price_i - cost_position_i - position_qty_i * (sum_unitary_funding_i - last_sum_unitary_funding_i)",
    "inputs": [
      {
        "key": "positions",
        "type": "object",
        "factorType": {
          "baseType": "object",
          "constraints": {},
          "nullable": false,
          "array": true,
          "properties": [
            {
              "key": "account_id",
              "type": "string",
              "factorType": {
                "baseType": "string",
                "nullable": true,
                "array": false
              }
            },
            {
              "key": "symbol",
              "type": "string",
              "factorType": {
                "baseType": "string",
                "nullable": false,
                "array": false
              }
            },
            {
              "key": "position_qty",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              }
            },
            {
              "key": "cost_position",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              }
            },
            {
              "key": "last_sum_unitary_funding",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              }
            },
            {
              "key": "pending_long_qty",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              }
            },
            {
              "key": "pending_short_qty",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              }
            },
            {
              "key": "settle_price",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              }
            },
            {
              "key": "average_open_price",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              }
            },
            {
              "key": "unrealized_pnl",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              }
            },
            {
              "key": "unrealized_pnl_index",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": true,
                "array": false
              }
            },
            {
              "key": "unrealized_pnl_ROI",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              }
            },
            {
              "key": "unsettled_pnl",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              }
            },
            {
              "key": "unsettled_pnl_ROI",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              }
            },
            {
              "key": "unrealized_pnl_ROI_index",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": true,
                "array": false
              }
            },
            {
              "key": "mark_price",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              }
            },
            {
              "key": "index_price",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": true,
                "array": false
              }
            },
            {
              "key": "est_liq_price",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": true,
                "array": false
              }
            },
            {
              "key": "timestamp",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              }
            },
            {
              "key": "mmr",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              },
              "description": "\nMaintenance margin ratio"
            },
            {
              "key": "imr",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              }
            },
            {
              "key": "IMR_withdraw_orders",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              }
            },
            {
              "key": "MMR_with_orders",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              }
            },
            {
              "key": "pnl_24_h",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              }
            },
            {
              "key": "fee_24_h",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              }
            },
            {
              "key": "fundingFee",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": true,
                "array": false
              }
            },
            {
              "key": "leverage",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              }
            },
            {
              "key": "sum_unitary_funding",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              }
            }
          ]
        }
      }
    ],
    "outputs": [
      {
        "key": "result",
        "type": "number",
        "factorType": {
          "baseType": "number",
          "nullable": false,
          "array": false
        },
        "description": "The total unrealized profit or loss of all positions."
      }
    ],
    "formulaText": "{\n  if (!Array.isArray(positions) || positions.length === 0) {\n    return 0;\n  }\n\n  return positions.reduce((acc, cur) => {\n    return (\n      acc +\n      unsettlementPnL({\n        positionQty: cur.position_qty,\n        markPrice: cur.mark_price,\n        costPosition: cur.cost_position,\n        sumUnitaryFunding: cur.sum_unitary_funding,\n        lastSumUnitaryFunding: cur.last_sum_unitary_funding,\n      })\n    );\n  }, 0);\n}",
    "sourceCode": "export function totalUnsettlementPnL(\n  positions: (API.Position & { sum_unitary_funding: number })[],\n): number {\n  if (!Array.isArray(positions) || positions.length === 0) {\n    return 0;\n  }\n\n  return positions.reduce((acc, cur) => {\n    return (\n      acc +\n      unsettlementPnL({\n        positionQty: cur.position_qty,\n        markPrice: cur.mark_price,\n        costPosition: cur.cost_position,\n        sumUnitaryFunding: cur.sum_unitary_funding,\n        lastSumUnitaryFunding: cur.last_sum_unitary_funding,\n      })\n    );\n  }, 0);\n}",
    "localNpmInfo": {
      "packageName": "@orderly.network/perp",
      "functionName": "totalUnsettlementPnL",
      "enabled": true
    }
  },
  {
    "id": "MMR",
    "name": "MMR",
    "version": "1.0.0",
    "description": "Calculates the maintenance margin requirement (MMR) of a position.",
    "inputs": [
      {
        "key": "inputs",
        "type": "object",
        "factorType": {
          "baseType": "object",
          "constraints": {},
          "nullable": false,
          "array": false,
          "properties": [
            {
              "key": "baseMMR",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              }
            },
            {
              "key": "baseIMR",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              }
            },
            {
              "key": "IMRFactor",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              }
            },
            {
              "key": "positionNotional",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              }
            },
            {
              "key": "IMR_factor_power",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              }
            }
          ]
        }
      }
    ],
    "outputs": [
      {
        "key": "result",
        "type": "number",
        "factorType": {
          "baseType": "number",
          "nullable": false,
          "array": false
        },
        "description": "The MMR of the position."
      }
    ],
    "formulaText": "{\n  const {\n    baseMMR,\n    baseIMR,\n    IMRFactor,\n    positionNotional,\n    IMR_factor_power = IMRFactorPower,\n  } = inputs;\n  return Math.max(\n    baseMMR,\n    new Decimal(baseMMR)\n      .div(baseIMR)\n      .mul(IMRFactor)\n      .mul(Math.pow(Math.abs(positionNotional), IMR_factor_power))\n      // .toPower(IMR_factor_power)\n      .toNumber(),\n  );\n}",
    "sourceCode": "export function MMR(inputs: MMRInputs): number {\n  const {\n    baseMMR,\n    baseIMR,\n    IMRFactor,\n    positionNotional,\n    IMR_factor_power = IMRFactorPower,\n  } = inputs;\n  return Math.max(\n    baseMMR,\n    new Decimal(baseMMR)\n      .div(baseIMR)\n      .mul(IMRFactor)\n      .mul(Math.pow(Math.abs(positionNotional), IMR_factor_power))\n      // .toPower(IMR_factor_power)\n      .toNumber(),\n  );\n}",
    "localNpmInfo": {
      "packageName": "@orderly.network/perp",
      "functionName": "MMR",
      "enabled": true
    }
  },
  {
    "id": "maxPositionNotional",
    "name": "maxPositionNotional",
    "version": "1.0.0",
    "description": "calculate the max position notional",
    "formula": "max_notional = ( (1/ (leverage * imr_factor) ) ^ (1/0.8)",
    "inputs": [
      {
        "key": "inputs",
        "type": "object",
        "factorType": {
          "baseType": "object",
          "constraints": {},
          "nullable": false,
          "array": false,
          "properties": [
            {
              "key": "leverage",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              },
              "description": "symbol leverage"
            },
            {
              "key": "IMRFactor",
              "type": "number",
              "factorType": {
                "baseType": "number",
                "nullable": false,
                "array": false
              }
            }
          ]
        }
      }
    ],
    "outputs": [
      {
        "key": "result",
        "type": "number",
        "factorType": {
          "baseType": "number"
        }
      }
    ],
    "formulaText": "{\n  const { leverage, IMRFactor } = inputs;\n  return new Decimal(1)\n    .div(new Decimal(leverage).mul(IMRFactor))\n    .pow(1 / 0.8)\n    .toNumber();\n}",
    "sourceCode": "export function maxPositionNotional(inputs: {\n  /** symbol leverage */\n  leverage: number;\n  IMRFactor: number;\n}) {\n  const { leverage, IMRFactor } = inputs;\n  return new Decimal(1)\n    .div(new Decimal(leverage).mul(IMRFactor))\n    .pow(1 / 0.8)\n    .toNumber();\n}",
    "localNpmInfo": {
      "packageName": "@orderly.network/perp",
      "functionName": "maxPositionNotional",
      "enabled": true
    }
  }
]